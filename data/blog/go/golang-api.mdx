---
title: 'API Service with Go: Zero to Production'
date: '2022-01-20'
tags: ['go', 'api', 'docker', 'log']
draft: false
summary: '‡∏à‡∏∞‡∏™‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á API Service ‡∏î‡πâ‡∏ß‡∏¢‡∏†‡∏≤‡∏©‡∏≤ Go ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£ deploy ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á'
---

# API Service with Go: Zero to Production

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏†‡∏≤‡∏©‡∏≤ Go ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ CRUD ‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö SQL ‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡πá‡∏à‡∏∞‡∏°‡∏≤‡∏•‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á API Service ‡∏Å‡∏±‡∏ô ‡∏ã‡∏∂‡πà‡∏á API ‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Application 2 ‡∏ï‡∏±‡∏ß ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á UI ‡∏Å‡∏±‡∏ö Database ‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î Protocal ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô REST ‡∏´‡∏£‡∏∑‡∏≠ GraphQL ‡∏´‡∏£‡∏∑‡∏≠ gRPC

‡πÉ‡∏ô‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Todo List API ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ REST ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á web ui ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö-‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏Å‡∏±‡∏ô‡πÅ‡∏ö‡∏ö JSON ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å, ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤, ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó ‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PostgreSQL ‡∏à‡∏ô‡πÑ‡∏õ‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£ deploy ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á docker image ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ deploy ‡∏ö‡∏ô production

<div className="flex justify-center">
  <div>![Flow](/static/images/go/golang-api/flow.png)</div>
</div>

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡∏î‡∏π‡∏î‡∏µ‡πÜ ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô API ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏à‡∏∞‡πÅ‡∏ö‡πà‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡πá‡∏ô 3 ‡∏™‡πà‡∏ß‡∏ô ‡∏Ñ‡∏∑‡∏≠

- Handler ‡∏ó‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
- Bussiness Logic ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á handler ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß
- Data Access Layer ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á‡πÜ

## HTTP Web Server

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Web Server ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ [net/http](https://pkg.go.dev/net/http) ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô standard library ‡∏Ç‡∏≠‡∏á Go ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢

### ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡πÉ‡∏´‡∏°‡πà

```bash
mkdir -p goapi
cd goapi
go mod init goapi
touch main.go
```

### ‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Web Server

```go:main.go
package main

import (
	"log"
	"net/http"
)

func main() {
	// starting server
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

<aside>
üí° ‡πÉ‡∏ô Windows ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á `go run main.go` ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å Windows Security Alert ‡∏ñ‡∏≤‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÅ‡∏Å‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å `":8080"` ‡πÄ‡∏õ‡πá‡∏ô `"localhost:8080"`

‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á Inboud Rules ‡πÉ‡∏ô Windows Defender Firewall ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ port 8080

</aside>

### Handler Functions and Request Multiplexer (Router)

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô server ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏•‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà `404 Not Found` ‡πÉ‡∏´‡πâ‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á Router ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Handler Functions

```go:main.go
func main() {
  // define route
	http.HandleFunc("/greet", func(w http.ResponseWriter, r *http.Request) {
	  fmt.Fprint(w, "Hello world")
  }

	// starting server
  log.Fatal(http.ListenAndServ(":8000", nil))
}

// ‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô ‡πÄ‡∏õ‡πá‡∏ô function ‡πÅ‡∏ó‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ

func main() {
  // define route
	http.HandleFunc("/greet", greet)

	// starting server
  log.Fatal(http.ListenAndServ(":8000", nil))
}

func greet(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Hello world")
}
```

### Request and Response Headers

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡πÇ‡∏î‡∏¢‡∏ô‡∏≥‡∏à‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô struct ‡∏°‡∏≤‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ú‡πà‡∏≤‡∏ô `json.NewEncoder.(w).Encode(struct)`

```go:main.go
package main

import (
	"encoding/json"
	"log"
	"net/http"
)

type Test struct {
	Name string
}

func main() {
	// define route
	http.HandleFunc("/tests", Test)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func Test(w http.ResponseWriter, r *http.Request) {
	tests := []Test{
		{Name: "Test 1"},
		{Name: "Test 2"},
    {Name: "Test 3"},
	}

	json.NewEncoder(w).Encode(todos)
}
```

‡πÅ‡∏ï‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ô‡∏±‡πà‡∏ô‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô `text/plain` ‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏ `"Content-Type"` ‡πÉ‡∏ô Response Header ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ `w.Header().Add("header", "data")`

```go:main.go
func Test(w http.ResponseWriter, r *http.Request) {
	tests := []Test{
		{Name: "Test 1"},
		{Name: "Test 2"},
    {Name: "Test 3"},
	}

  w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todos)
}
```

‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Request header ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ `r.Header.Get("header")`

```go:main.go
func Test(w http.ResponseWriter, r *http.Request) {
	tests := []Test{
		{Name: "Test 1"},
		{Name: "Test 2"},
    {Name: "Test 3"},
	}

  if r.Header.Get("Accept") == "application/xml" {
		w.Header().Add("Content-Type", "application/xml")
		xml.NewEncoder(w).Encode(tests)
	} else {
		w.Header().Add("Content-Type", "application/json")
		json.NewEncoder(w).Encode(tests)
	}
}
```

## Routing with gorialla/mux

http handler ‡πÉ‡∏ô go ‡∏ô‡∏±‡πâ‡∏ô ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô mux ‡πÅ‡∏ó‡∏ô‡πÑ‡∏î‡πâ‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ

```go:main.go
func main() {
  mux := http.NewServeMux()
  // define route
	mux.HandleFunc("/tests", Test)

	// starting server
  log.Fatal(http.ListenAndServ(":8080", mux))
}
```

‡πÅ‡∏ï‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤ [net/http](https://pkg.go.dev/net/http) ‡πÉ‡∏ô Go ‡∏ô‡∏±‡πâ‡∏ô ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á routing ‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏î‡∏µ ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏´‡∏≤ package ‡∏≠‡∏∑‡πà‡∏ô‡∏°‡∏≤‡∏ä‡πà‡∏ß‡∏¢‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏ó‡∏ô ‡πÇ‡∏î‡∏¢‡πÉ‡∏ô‡∏ï‡∏±‡∏≠‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÉ‡∏ä‡πâ [gorilla/mux](https://github.com/gorilla/mux)

### ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á [gorilla/mux](https://github.com/gorilla/mux)

```bash
go get -u github.com/gorilla/mux
```

### ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô [gorilla/mux](https://github.com/gorilla/mux)

```go:main.go
import (
  "log"
  "net/http"
  "github.com/gorilla/mux"
)

func main() {
  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
  r := mux.NewRouter()
  // define route
	mux.HandleFunc("/tests", Test)

	// starting server
  log.Fatal(http.ListenAndServ(":8000", r))
}
```

### Query Parameters

‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ `r.URL.Query()` ‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ `key` ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô `[]string`

```go:main.go
func Test(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(query)
}

// http://localhost:8080/tests?name=abc&completed=true
// {
// 	"completed": [
// 		"true"
// 	],
// 	"name": [
// 		"abc"
// 	]
// }
```

<aside>
üí° ‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á string ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô bool ‡πÉ‡∏ä‡πâ `strconv.ParseBool(query["completed"][0])`

</aside>

### URL Parameters

‡∏Å‡∏≥‡∏´‡∏ô‡∏î path ‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ `"/todos/{id}"` ‡πÅ‡∏•‡∏∞‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÉ‡∏ä‡πâ `mux.Vars(r)` ‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ `key` ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô `string`

```go:main.go
func main() {
	// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
	r := mux.NewRouter()
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	r.HandleFunc("/tests/{id:[0-9]+}", func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		fmt.Fprint(w, vars["id"])
	})

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}
```

<aside>
üí° ‡∏Ñ‡πà‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô string ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô int ‡πÉ‡∏ä‡πâ `strconv.Atoi(vars["id"])`

</aside>

### Methods

‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ method ‡πÅ‡∏Ñ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° `.Methods(http.MethodGet)` ‡πÑ‡∏õ‡∏´‡∏•‡∏±‡∏á `HandleFunc()` ‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ HandleFunc ‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞ Method ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏ä‡πà‡∏ô

```go:main.go
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

func main() {
	// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
	r := mux.NewRouter()
	// define route for crud
	r.HandleFunc("/tests", createTest).Methods(http.MethodPost)
  r.HandleFunc("/tests", listTest).Methods(http.MethodGet)
  // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
  r.HandleFunc("/tests/{id:[0-9]+}", getTest).Methods(http.MethodGet)
  r.HandleFunc("/tests/{id:[0-9]+}", updateTest).Methods(http.MethodPut)
  r.HandleFunc("/tests/{id:[0-9]+}", deleteTest).Methods(http.MethodDelete)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}
```

## Todo List API

Todo List API ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

- Method POST `/api/todos` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà
- Method GET `/api/todos` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- Method GET `/api/todos/{id:[0-9]+}` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏° id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
- Method PATCH `/api/todos/{id:[0-9]+}` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ï‡∏≤‡∏° id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
- Method DELETE `/api/todos/{id:[0-9]+}` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏° id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏à‡∏≤‡∏Å handlers ‡∏ã‡∏∂‡πà‡∏á‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÅ‡∏¢‡∏Å‡πÑ‡∏ß‡πâ‡πÉ‡∏ô module handlers

```bash
mkdir handlers
cd handlers
touch todo.go
```

### Todo struct

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å API ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö-‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á struct ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON

```go:handlers/todo.go
package handlers

type Todo struct {
	ID        uint   `json:"id"`
	Title     string `json:"text"`
	Completed bool   `json:"isCompleted"`
}
```

<aside>
üí° ‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ field ‡πÉ‡∏ô JSON ‡∏à‡∏∞‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô `text`, `isCompleted` ‡πÅ‡∏ï‡πà‡πÉ‡∏ô struct ‡∏à‡∏∞‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô `Title`, `Completed` ‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö

</aside>

### Handlers

‡∏™‡∏£‡πâ‡∏≤‡∏á handlers ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ routes ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

```go:handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Create Todo")
}

func ListTodo(w http.ResponseWriter, r *http.Request) {
  todos := []Todo{
		{ID: 1, Title: "Test 1", Completed: true},
		{ID: 2, Title: "Test 2", Completed: false},
		{ID: 3, Title: "Test 3", Completed: false},
	}
  // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todos)
}

func GetTodo(w http.ResponseWriter, r *http.Request) {
  vars := mux.Vars(r)
	fmt.Fprint(w, "Get Todo by ID:", vars["id"])
}

func UpdateTodoStatus(w http.ResponseWriter, r *http.Request) {
  vars := mux.Vars(r)
	fmt.Fprint(w, "Update Todo Status by ID:", vars["id"])
}

func DeleteTodo(w http.ResponseWriter, r *http.Request) {
  vars := mux.Vars(r)
	fmt.Fprint(w, "Delete Todo by ID:", vars["id"])
}
```

### ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Router

‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡∏∑‡πà‡∏≠ setupRouter() ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ routes ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏ó‡∏µ‡πà `main.go`

```go:main.go
package main

import (
	"goapi/handlers"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

func main() {
	// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
	r := mux.NewRouter()
	// define route
	setupRouter(r)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}

func setupRouter(r *mux.Router) {
	r.HandleFunc("/api/todos", handlers.CreateTodo).Methods(http.MethodPost)
	r.HandleFunc("/api/todos", handlers.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	r.HandleFunc("/api/todos/{id:[0-9]+}", handlers.GetTodo).Methods(http.MethodGet)
	r.HandleFunc("/api/todos/{id:[0-9]+}", handlers.UpdateTodo).Methods(http.MethodPut)
	r.HandleFunc("/api/todos/{id:[0-9]+}", handlers.DeleteTodo).Methods(http.MethodDelete)
}
```

‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡∏ó‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡∏≠‡∏á `/todos` ‡πÇ‡∏î‡∏¢‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô subrouter ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡πá‡πÑ‡∏î‡πâ

```go:main.go
func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
	todo.HandleFunc("", handlers.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", handlers.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", handlers.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", handlers.UpdateTodo).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", handlers.DeleteTodo).Methods(http.MethodDelete)
}
```

## ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Database

‡∏à‡∏≤‡∏Å‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Database ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á standard library ‡∏´‡∏£‡∏∑‡∏≠ sqlx ‡∏´‡∏£‡∏∑‡∏≠ gorm ‡∏Å‡πá‡πÑ‡∏î‡πâ‡∏ã‡∏∂‡πà‡∏á‡πÉ‡∏ô‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ gorm ‡πÅ‡∏•‡∏∞‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô PostgreSQL

- ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á ‚Ä£ ‡πÅ‡∏•‡∏∞ database driver

```bash
go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres
```

- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Database ‡πÇ‡∏î‡∏¢‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `database/database.go`

```go:database/database.go
package database

import (
	"log"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

const (
	// TODO fill this in directly or through environment variable
	// Build a DSN e.g. postgres://username:password@host:port/dbName
	// or "host=localhost user=gorm password=gorm dbname=gorm port=5432 sslmode=disable TimeZone=Asia/Bangkok"
	DB_DSN = "postgres://fcricryh:F5a7wATfocTUNww1Dm14AfebtPaysqIn@john.db.elephantsql.com/fcricryh"
)

var DB *gorm.DB

func ConnectDB() {
	var err error
	DB, err = gorm.Open(postgres.Open(DB_DSN), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})

	if err != nil {
		log.Fatal("Cannot open DB connection", err)
	}

	log.Println("DB Connected")
}
```

- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```go:main.go
func main() {
  // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î server ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ñ‡πâ‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á start server
	database.ConnectDB()


	r := mux.NewRouter()
	// define route
	setupRouter(r)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}
```

### ‡∏™‡∏£‡πâ‡∏≤‡∏á Model

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å GORM ‡πÄ‡∏õ‡πá‡∏ô ORM ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Model ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô `struct` ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô

‡πÉ‡∏´‡πâ‡πÑ‡∏õ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç `Todo` struct ‡πÉ‡∏ô `handlers/todo.go` ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠ column ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ ‡∏Ñ‡∏∑‡∏≠ is_done ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ gorm tag `column`

```go:handlers/todo.go
type Todo struct {
	ID        uint   `json:"id"`
	Title     string `json:"text"`
	Completed bool   `json:"completed" gorm:"column:is_done"`
}
```

## Bussiness Logic

‡∏ñ‡∏±‡∏î‡∏°‡∏≤‡∏à‡∏∞‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏±‡∏ô ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏™‡πà bussiness logic ‡∏ó‡∏µ‡πà handlers ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß ‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πà‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

### CreateTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method POST `/todos` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô JSON `{"text", "do something"}` ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Todo struct ‡∏ñ‡πâ‡∏≤‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 400 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	var todo Todo

	err := json.NewDecoder(r.Body).Decode(&todo)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

}
```

- Step 2: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 400 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  if todo.Title == "" {
    http.Error(w, "text is required", http.StatusBadRequest)
		return
  }
}
```

‡πÅ‡∏ï‡πà‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡πÜ fields ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ package [validator](https://github.com/go-playground/validator) ‡πÅ‡∏ó‡∏ô ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£ tag `validate` ‡∏•‡∏á‡πÑ‡∏õ‡πÉ‡∏ô struct

‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô `go get github.com/go-playground/validator/v10`

```go:handlers/todo.go
type Todo struct {
	ID        uint   `json:"id"`
	Title     string `json:"text" validate:"required"`
	Completed bool   `json:"completed" gorm:"column:is_done"`
}

// use a single instance of Validate, it caches struct info
var validate *validator.Validate = validator.New()

func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  // returns nil or ValidationErrors ( []FieldError )
	err = validate.Struct(todo)
	if err != nil {
		errMsg := ""

		for _, err := range err.(validator.ValidationErrors) {
			errMsg += err.Error() + "\n"
		}
		http.Error(w, errMsg, http.StatusBadRequest)
		return
	}
}
```

- Step 3: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 500 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  // step 3: insert
  tx := database.DB.Create(&todo)
  if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 4: ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô 201

```go:handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  // step 3: insert
  // step 4: response
  w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(todo)
}
```

<aside>
üí° ‡πÇ‡∏î‡∏¢‡∏õ‡∏Å‡∏ï‡∏¥‡∏ñ‡πâ‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏à‡∏∞‡πÑ‡∏î‡πâ reponse status 200 ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô status ‡∏≠‡∏∑‡πà‡∏ô ‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏õ‡πá‡∏ô 201 ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ `w.WriteHeader(http.StatusCreated)` ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏•‡πà‡∏≤‡∏á `w.Header().Add()` ‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô header `"Content-Type"` ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ

</aside>

### ListTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method GET `/todos` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 500 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func ListTodo(w http.ResponseWriter, r *http.Request) {
  // step 1: query all todos from database
	todos := []Todo{}

	tx := database.DB.Find(&todos)

	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 2: ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON

```go:handlers/todo.go
func ListTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: query all todos from database
  // step 2: response
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todos)
}
```

‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ó‡∏≤‡∏á query parameters ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡πá‡πÑ‡∏î‡πâ ‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

```go:handlers/todo.go
func ListTodo(w http.ResponseWriter, r *http.Request) {
  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å query params
  query := r.URL.Query()
  wheres := map[string]interface{}{}
  // ‡∏ñ‡πâ‡∏≤‡∏™‡πà‡∏á completed ‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡πÉ‡∏™‡πà‡πÑ‡∏õ‡πÉ‡∏ô map["is_done"] ‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠ column ‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	if val, ok := query["completed"]; ok {
		b1, err := strconv.ParseBool(val[0])
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		wheres["is_done"] = b1
	}

  todos := []Todo{}
  // ‡πÄ‡∏û‡∏¥‡πà‡∏° .Where()
	tx := database.DB.Where(wheres).Find(&todos)

	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todos)
}
```

### GetTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method GET `/todos/{id:[0-9]+}` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ id ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

```go:handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
}
```

<aside>
üí° ‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ id ‡∏à‡∏≤‡∏Å string ‡πÄ‡∏õ‡πá‡∏ô int ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö error ‡πÑ‡∏î‡πâ ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡πÉ‡∏ä‡πâ regex ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô

</aside>

- Step 2: ‡∏ô‡∏≥‡∏Ñ‡πà‡∏≤ id ‡πÑ‡∏õ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 500 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: select where id
	todo := Todo{}
	tx := database.DB.First(&todo, id)
	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 3: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 404 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: select where id
  todo := Todo{}
	tx := database.DB.First(&todo, id)
	if err := tx.Error; err != nil {
    // step 3: handle error not found
    if errors.Is(err, gorm.ErrRecordNotFound) {
      http.Error(w, "todo with given id not found", http.StatusNotFound)
		  return
    }
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 4: ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON

```go:handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: select where id
  // step 3: handle error not found
  // step 4: response
  w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todo)
}
```

### UpdateTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method PUT `/todos/{id:[0-9]+}` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ id ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

```go:handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
}
```

- Step 2: ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô JSON `{"isCompleted", true}` ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Todo struct

```go:handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  var todo Todo
	err := json.NewDecoder(r.Body).Decode(&todo)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
}
```

- Step 3: ‡∏ô‡∏≥‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏õ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏°‡∏≤

```go:handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  // step 3: update only is_done column
  tx := database.DB.Model(Todo{ID: uint(id)}).Update("is_done", todo.Completed)
	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 4: ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ id ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 404 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  // step 3: update only is_done column
  // step 4: handle not found error
  if tx.RowsAffected == 0 {
		http.Error(w, "todo with given id not found", http.StatusNotFound)
		return
	}
}
```

- Step 5: ‡∏ñ‡πâ‡∏≤‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡πÅ‡∏Ñ‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ 204 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  // step 3: update only is_done column
  // step 4: handle not found error
  // step 5: response
  w.WriteHeader(http.StatusNoContent)
}
```

### DeleteTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method DELETE `/todos/{id:[0-9]+}` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ id ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

```go:handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
}
```

- Step 2: ‡∏ô‡∏≥‡∏Ñ‡πà‡∏≤ id ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏õ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

```go:handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: delete where id
  tx := database.DB.Delete(&Todo{}, id)
	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 3: ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ id ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 404 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: delete where id
  // step 3: handle not found error
  if tx.RowsAffected <= 0 {
		http.Error(w, "todo with given id not found", http.StatusNotFound)
		return
	}
}
```

- Step 4: ‡∏ñ‡πâ‡∏≤‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡πÅ‡∏Ñ‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ 204 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: delete where id
  // step 3: handle not found error
  // step 4: response
  w.WriteHeader(http.StatusNoContent)
}
```

### Use Method Style

‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡∏ä‡∏≠‡∏ö‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô handler ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á method ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ function ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡∏™‡πà‡∏á depencies ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏°‡∏≤‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á handler ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÅ‡∏ó‡∏ô

- ‡∏™‡∏£‡πâ‡∏≤‡∏á todoHandler struct ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≥‡∏´‡∏ô‡∏î depencies ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```go:handlers/todo.go
type todoHandler struct {
	db       *gorm.DB
	validate *validator.Validate
}

func NewTodoHandler(db *gorm.DB, validate *validator.Validate) *todoHandler {
	return &todoHandler{
		db:       db,
		validate: validate,
	}
}
```

- ‡πÅ‡∏Å‡πâ handlers function ‡πÄ‡∏õ‡πá‡∏ô method ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÄ‡∏õ‡πá‡∏ô receiver function

```go:handlers/todo.go
func (h todoHandler) CreateTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	err = h.validate.Struct(todo)
  // ...
	tx := h.db.Create(&todo)
  // ...
}

func (h todoHandler) ListTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	tx := h.db.Where(wheres).Find(&todos)
  // ...
}

func (h todoHandler) GetTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	tx := h.db.First(&todo, id)
  // ...
}

func (h todoHandler) UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// ...
	tx := h.db.Model(Todo{ID: uint(id)}).Update("is_done", todo.Completed)
  // ...
}

func (h todoHandler) DeleteTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	tx := h.db.Delete(&Todo{}, id)
  // ...
}
```

- ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà `main.go`

```go:main.go
// use a single instance of Validate, it caches struct info
var validate *validator.Validate

func main() {
	database.ConnectDB()

	validate = validator.New()
  // ...
}

func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
	todoHandler := handlers.NewTodoHandler(database.DB, validate)
	todo.HandleFunc("", todoHandler.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", todoHandler.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.UpdateTodo).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.DeleteTodo).Methods(http.MethodDelete)
}
```

## Error Handling

‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‡πÅ‡∏ï‡πà‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å API Service ‡∏ô‡∏µ‡πâ ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á `AppError` struct ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà `errs/errs.go`

```go:errs/errs.go
package errs

import "net/http"

type AppError struct {
	Code    int    `json:"-"`  // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á code
	Message string `json:"message"`
}

func NewBadRequestError(message string) *AppError {
	return &AppError{
		Code:    http.StatusBadRequest,
		Message: message,
	}
}

func NewNotFoundError(message string) *AppError {
	return &AppError{
		Code:    http.StatusNotFound,
		Message: message,
	}
}

func NewUnexpectedError(message string) *AppError {
	return &AppError{
		Code:    http.StatusInternalServerError,
		Message: message,
	}
}
```

### ‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```go:handlers/todo.go
func (h todoHandler) GetTodo(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)

	id, _ := strconv.Atoi(vars["id"])

	todo := Todo{}

	tx := h.db.First(&todo, id)
	if err := tx.Error; err != nil {
		appErr := errs.NewUnexpectedError(err.Error())
		if errors.Is(err, gorm.ErrRecordNotFound) {
			appErr = errs.NewNotFoundError("todo with given id not found")
		}

		w.Header().Add("Content-Type", "application/json")
		w.WriteHeader(appErr.Code)
		json.NewEncoder(w).Encode(appErr)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todo)
}
```

### Refactor

‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö JSON ‡∏à‡∏∞‡∏°‡∏µ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ã‡πâ‡∏≥‡πÜ ‡∏Å‡∏±‡∏ô ‡∏Ñ‡∏∑‡∏≠ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Content-Type, ‡∏Å‡∏≥‡∏´‡∏ô‡∏î respone code ‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á struct ‡πÄ‡∏õ‡πá‡∏ô JSON ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏≠‡∏≤‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏¢‡∏Å‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡πâ‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

```go:handlers/todo.go
func writeResponse(w http.ResponseWriter, code int, data interface{}) {
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(data)
}
```

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏à‡∏∞‡∏î‡∏π clean ‡∏Ç‡∏∂‡πâ‡∏ô

```go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)

	id, _ := strconv.Atoi(vars["id"])

	todo := Todo{}

	tx := database.DB.First(&todo, id)
	if err := tx.Error; err != nil {
		appErr := errs.NewUnexpectedError(err.Error())
		if errors.Is(err, gorm.ErrRecordNotFound) {
			appErr = errs.NewNotFoundError("todo with given id not found")
		}

		writeResponse(w, appErr.Code, appErr)
		return
	}

	writeResponse(w, http.StatusOK, todo)
}
```

## Middleware

Middleware ‡∏Ñ‡∏∑‡∏≠ function ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö handler ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô handler ‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏´‡πà‡∏≠ handler ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡∏ó‡∏≥‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å handler ‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à ‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ middleware ‡∏´‡πà‡∏≠‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÜ ‡∏ä‡∏±‡πâ‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏∞‡∏á‡∏≤‡∏ô‡∏à‡∏≤‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡∏≠‡∏Å‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á handler ‡πÅ‡∏•‡∏∞‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡πÉ‡∏ô‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡∏≠‡∏Å‡∏™‡∏∏‡∏î

‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏≠‡∏≤‡∏°‡∏≤‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ access log ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ authentication ‡∏Å‡πá‡πÑ‡∏î‡πâ

- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ Access log

```go:middleware/middleware.go
package middleware

import (
	"log"
	"net/http"
	"time"
)

func Logging(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, req)
		log.Printf("%s %s %s", req.Method, req.RequestURI, time.Since(start))
	})
}
```

- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏≥ Authentication

```go:middleware/middleware.go
type authenticationMiddleware struct {
	tokenUsers map[string]string
}

func NewAuthenticationMiddleware() *authenticationMiddleware {
	m := map[string]string{}
	m["1111"] = "user1"
	m["2222"] = "user2"

	return &authenticationMiddleware{
		tokenUsers: m,
	}
}

// Middleware function, which will be called for each request
func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("x-token")

		if user, found := amw.tokenUsers[token]; found {
			// We found the token in our map
			log.Printf("Authenticated user %s\n", user)
			// Pass down the request to the next middleware (or final handler)
			next.ServeHTTP(w, r)
		} else {
			// Write an error and stop the handler chain
			http.Error(w, "Forbidden", http.StatusForbidden)
		}
	})
}
```

- ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ

```go:main.go
func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
  todoHandler := handlers.NewTodoHandler(database.DB, validate)
	todo.HandleFunc("", todoHandler.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", todoHandler.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.UpdateTodo).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.DeleteTodo).Methods(http.MethodDelete)

	// Set up middleware.
	amw := middleware.NewAuthenticationMiddleware()
	r.Use(amw.Middleware)
	r.Use(middleware.Logging)
}

// request -> logging -> authen -> router
```

- ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ authen ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ `/api/todos`

```go:main.go
func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
	todo.HandleFunc("", handlers.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", handlers.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", handlers.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", handlers.UpdateTodo).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", handlers.DeleteTodo).Methods(http.MethodDelete)

  r.HandleFunc("/public", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "This is public route")
	})
	// Set up middleware.
	amw := middleware.NewAuthenticationMiddleware()
	todo.Use(amw.Middleware)  // <-- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å r ‡πÄ‡∏õ‡πá‡∏ô todo ‡πÅ‡∏ó‡∏ô
	r.Use(middleware.Logging)
}

// request -> logging -> authen -> router
```

## **Handling CORS Requests**

‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤ web ‡∏à‡∏≤‡∏Å repo ‡∏ô‡∏µ‡πâ

[GitHub - somprasongd/todo-react-app at 5-http-requests](https://github.com/somprasongd/todo-react-app/tree/5-http-requests)

<aside>
üí° ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏≠‡∏≤ authen middleware ‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô

</aside>

‡∏à‡∏∞‡∏û‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏∞‡πÑ‡∏£‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏°‡∏µ error `‚Äústrict-origin-when-cross-origin‚Äù` ‡∏ã‡∏∂‡πà‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ package [cors](https://github.com/rs/cors) ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏ä‡πà‡∏ß‡∏¢ ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ

‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô `go get github.com/rs/cors`

```go:main.go
func main() {
	database.ConnectDB()

	// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
	r := mux.NewRouter()
	// define route
	setupRouter(r)

  // Handling CORS Requests
	c := cors.New(cors.Options{
		AllowCredentials: true,
		AllowedMethods:   []string{"GET", "POST", "PATCH", "DELETE", "OPTIONS"},
	})

	handler := c.Handler(r)
	// starting server
	log.Fatal(http.ListenAndServe(":8080", handler))
}
```

‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢... ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ API ‡∏à‡∏≤‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß

## Non Functional Requirements

‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ API Service ‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ï‡∏≤‡∏° requirements ‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏±‡πâ‡∏ô ‡∏¢‡∏±‡∏á‡∏°‡∏µ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÉ‡∏´‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏î‡πâ

### Configuration

‡∏Ñ‡πà‡∏≤ configuration ‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° ‡πÄ‡∏ä‡πà‡∏ô server port ‡πÅ‡∏•‡∏∞ dsn ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö database ‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏•‡∏á‡πÑ‡∏õ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏£‡∏á‡πÜ ‡∏Ñ‡∏ß‡∏£‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤ environments ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡πÑ‡∏õ deploy

‡∏ã‡∏∂‡πà‡∏á‡πÉ‡∏ô‡∏†‡∏≤‡∏©‡∏≤ Go ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ environment ‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å `os.Getenv("APP_PORT")`

```go:main.go
  // starting server
	port := os.Getenv("APP_PORT")
	log.Println(fmt.Sprintf("Starting server at port %v", port))
	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%v", port), handler))
```

<aside>
üí° ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°
$ APP_PORT=8081 go run .
2022/02/02 10:10:52 Starting server at port 8081

</aside>

‡∏ã‡∏∂‡πà‡∏á‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° `APP_PORT` ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡∏ï‡∏•‡∏≠‡∏î ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡πâ‡∏≤‡∏°‡∏µ environment ‡∏´‡∏•‡∏≤‡∏¢‡∏ï‡∏±‡∏ß ‡∏ï‡πâ‡∏≠‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå‡∏£‡∏∞‡∏ö‡∏∏‡πÑ‡∏õ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏ã‡∏∂‡πà‡∏á‡∏ñ‡πâ‡∏≤‡∏Ç‡∏ì‡∏∞‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏°‡πà‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÅ‡∏ô‡πà‡πÜ ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡πÉ‡∏™‡πà‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏∞‡πÉ‡∏´‡πâ‡∏°‡∏≤‡∏≠‡πà‡∏≤‡∏ô config ‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ó‡∏ô ‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡∏à‡∏£‡∏¥‡∏á ‡∏Å‡πá‡πÉ‡∏´‡πâ‡πÑ‡∏õ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å environment ‡πÅ‡∏ó‡∏ô

package ‡∏ó‡∏µ‡πà‡∏ô‡∏¥‡∏¢‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡∏±‡∏ô ‡∏Ñ‡∏∑‡∏≠ [godotenv](https://github.com/joho/godotenv) ‡∏ã‡∏∂‡πà‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡πÅ‡∏ö‡∏ö key=value ‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå `.env` ‡πÅ‡∏ï‡πà‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô [viper](https://github.com/spf13/viper) ‡πÅ‡∏ó‡∏ô ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ config ‡∏Ñ‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö ‡πÄ‡∏ä‡πà‡∏ô yaml

- ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á viper `go get github.com/spf13/viper`
- ‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤ config ‡∏•‡∏á‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå `config.yaml` ‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

```yaml:config.yaml
app:
  port: 8080

db:
  driver: 'postgres'
  host: 'john.db.elephantsql.com'
  port: 5432
  username: 'fcricryh'
  password: 'F5a7wATfocTUNww1Dm14AfebtPaysqIn'
  database: 'fcricryh'
```

- ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå config ‡πÇ‡∏î‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå `config/config.go`

```go:config/config.go
package config

import (
	"fmt"
	"strings"

	"github.com/spf13/viper"
)

func LoadConfig() {
	viper.SetConfigName("config")                          // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå config (without extension)
	viper.SetConfigType("yaml")                            // ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config
	viper.AddConfigPath(".")                               // ‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà working directory

	err := viper.ReadInConfig() // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config
	if err != nil {             // ‡∏ñ‡πâ‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ panic ‡πÑ‡∏õ‡πÄ‡∏•‡∏¢
		panic(fmt.Errorf("fatal error config file: %w", err))
	}
}
```

- ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÉ‡∏ä‡πâ `viper.GetXXX("‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ . dot notation")`

```go:main.go
func main() {
	config.LoadConfig()
	database.ConnectDB()
  // ...
	// starting server
	port := viper.GetInt("app.port")
	logger.Info(fmt.Sprintf("Starting server at port %v", port))
	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%v", port), handler))
}
```

- ‡πÅ‡∏ï‡πà‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á ‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤ environment ‡∏°‡∏≤‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö APP_PORT ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏° config ‡πÉ‡∏´‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ environment ‡πÉ‡∏´‡πâ‡∏î‡πâ‡∏ß‡∏¢ ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà `panic` ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏ü‡∏•‡πå config

```go:config/config.go
func init() {
	viper.SetConfigName("config")                          // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå config (without extension)
	viper.SetConfigType("yaml")                            // ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config
	viper.AddConfigPath(".")                               // ‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà working directory
	viper.AutomaticEnv()                                   // ‡πÉ‡∏´‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å env ‡∏°‡∏≤ replace ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå config
	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_")) // ‡πÅ‡∏õ‡∏•‡∏á _ underscore ‡πÉ‡∏ô env ‡πÄ‡∏õ‡πá‡∏ô . dot notation ‡πÉ‡∏ô viper

	err := viper.ReadInConfig() // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config
	if err != nil {             // ‡∏ñ‡πâ‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å env ‡∏°‡∏≤‡πÅ‡∏ó‡∏ô‡πÑ‡∏î‡πâ
		fmt.Println("please consider environment variables", err.Error())
	}
}

// APP_PORT=8081 go run .
```

- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ default ‡πÄ‡∏ä‡πà‡∏ô ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏ app.port ‡∏°‡∏≤ ‡πÉ‡∏´‡πâ default ‡πÄ‡∏õ‡πá‡∏ô 8080

```go:config/config.go
func LoadConfig() {
	viper.SetConfigName("config")                          // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå config (without extension)
	viper.SetConfigType("yaml")                            // ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config
	viper.AddConfigPath(".")                               // ‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà working directory
	viper.AutomaticEnv()                                   // ‡πÉ‡∏´‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å env ‡∏°‡∏≤ replace ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå config
	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_")) // ‡πÅ‡∏õ‡∏•‡∏á _ underscore ‡πÉ‡∏ô env ‡πÄ‡∏õ‡πá‡∏ô . dot notation ‡πÉ‡∏ô viper

	err := viper.ReadInConfig() // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config
	if err != nil {             // ‡∏ñ‡πâ‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å env ‡∏°‡∏≤‡πÅ‡∏ó‡∏ô‡πÑ‡∏î‡πâ
		fmt.Println("please consider environment variables", err.Error())
	}

  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Default Value
	viper.SetDefault("app.port", 8080)
}
```

- ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á struct ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ config ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ

```go:config/config.go
package config

import (
	"fmt"
	"log"
	"strings"

	"github.com/spf13/viper"
)

type configuration struct {
	App appConfig
	Db  dbConfig
}

type appConfig struct {
	Port uint
}

type dbConfig struct {
	Driver   string
	Host     string
	Port     uint
	Username string
	Password string
	Database string
}

var Config *configuration

func LoadConfig() {
	viper.SetConfigName("config")                          // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå config (without extension)
	viper.SetConfigType("yaml")                            // ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config
	viper.AddConfigPath(".")                               // ‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå config ‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà working directory
	viper.AutomaticEnv()                                   // ‡πÉ‡∏´‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å env ‡∏°‡∏≤ replace ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå config
	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_")) // ‡πÅ‡∏õ‡∏•‡∏á _ underscore ‡πÉ‡∏ô env ‡πÄ‡∏õ‡πá‡∏ô . dot notation ‡πÉ‡∏ô viper

	err := viper.ReadInConfig() // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config
	if err != nil {             // ‡∏ñ‡πâ‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå config ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å env ‡∏°‡∏≤‡πÅ‡∏ó‡∏ô‡πÑ‡∏î‡πâ
		fmt.Println("please consider environment variables", err.Error())
	}

	// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Default Value
	viper.SetDefault("app.port", 8080)

	// Decode config ‡∏î‡πâ‡∏ß‡∏¢ Unmarshling
	Config = &configuration{}
	err = viper.Unmarshal(Config)
	if err != nil {
		log.Fatalf("unable to decode config into struct, %v", err)
	}
}
```

<aside>
üí° ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô struct ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ `port := config.Config.App.Port`

</aside>

- ‡πÅ‡∏ï‡πà‡∏Å‡∏≤‡∏£ Decode config ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ Unmarshling ‡∏ô‡∏±‡πâ‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ config ‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤ environments ‡∏ú‡πà‡∏≤‡∏ô `viper.AutomaticEnv()` ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏™‡∏£‡πâ‡∏≤‡∏á struct `Config` ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÄ‡∏≠‡∏á‡πÅ‡∏ó‡∏ô

```go:config/config.go
func LoadConfig() {
	// ...

	// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Default Value
	viper.SetDefault("app.port", 8080)

	Config = &configuration{
		App: appConfig{
			Port: viper.GetUint("app.port"),
		},
		Db: dbConfig{
			Driver:   viper.GetString("db.driver"),
			Host:     viper.GetString("db.host"),
			Port:     viper.GetUint("db.port"),
			Username: viper.GetString("db.username"),
			Password: viper.GetString("db.password"),
			Database: viper.GetString("db.database"),
		},
  }
  // err = viper.Unmarshal(Config)
	// if err != nil {
	// 	log.Fatalf("unable to decode config into struct, %v", err)
	// }
}
```

- ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ config ‡∏°‡∏≤‡∏Ñ‡∏£‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ [validator](https://github.com/go-playground/validator)

```go:config/config.go
func LoadConfig() {
  // ...
	// Config := &configuration{...}

	// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡∏°‡∏≤‡∏Ñ‡∏£‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
	validate := validator.New()

	err = validate.Struct(Config)
	if err != nil {
		log.Fatalf("load config error, %v", err)
	}
}
```

### Rate Limit

‡πÉ‡∏ô‡∏ö‡∏≤‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á api ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ô‡∏≤‡∏ô ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏õ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô api ‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô api ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏π‡∏á‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö request ‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ ‡πÇ‡∏î‡∏¢‡∏ä‡πâ package [golang.org/x/time/rate](http://golang.org/x/time/rate)

**‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á** ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö 10 req/sec ‡πÉ‡∏´‡πâ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ `limiter := rate.Newlimiter(10, 1)` ‡πÇ‡∏î‡∏¢ `10` ‡∏Ñ‡∏∑‡∏≠‡∏à‡∏≥‡∏ô‡∏ß‡∏ô limit per sec ‡πÅ‡∏•‡∏∞ `1` ‡∏Ñ‡∏∑‡∏≠ ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á burst size ‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏õ‡πá‡∏ô `limiter := rate.Newlimiter(5, 5)` ‡∏Å‡πá‡πÑ‡∏î‡πâ

```go:main.go
package main
import (
  "fmt"
  "log"
  "net/http"
  "golang.org/x/time/rate"
)
func main() {
  limiter := rate.NewLimiter(10, 1)
  http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request){
    if !limiter.Allow() {
      w.WriteHeader(http.StatusTooManyRequests)
      return
    }
  fmt.Fprintln(w, "Hello, World")
  })
  log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### **Graceful Shutdown**

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà API ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏±‡πâ‡∏ô ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏°‡∏µ request ‡∏´‡∏•‡∏≤‡∏¢‡πÜ ‡πÉ‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô ‡∏ã‡∏∂‡πà‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ request ‡∏Å‡πá‡∏Ñ‡∏∑‡∏≠ goroutine ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà main ‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô goroutine ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏ñ‡∏π‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢ ‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á

‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö signal ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡πÇ‡∏î‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏±‡∏ö request ‡πÄ‡∏û‡∏¥‡πà‡∏° ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∂‡∏á‡∏à‡∏∞ shutdown service ‡πÑ‡∏î‡πâ

<aside>
üí° SIGINT ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì interrupt ‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏î ctrl+c
SIGTERM ‡πÄ‡∏ä‡πà‡∏ô ‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î pod ‡∏à‡∏≤‡∏Å kubernates

</aside>

```go:main.go
package main

import (
    "context"
    "flag"
    "log"
    "net/http"
    "os"
    "os/signal"
    "time"

    "github.com/gorilla/mux"
)

func main() {
    var wait time.Duration
    flag.DurationVar(&wait, "graceful-timeout", time.Second * 15, "the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m")
    flag.Parse()

    r := mux.NewRouter()
    // Add your routes as needed

    srv := &http.Server{
		Addr: "0.0.0.0:8080",
		// Good practice to set timeouts to avoid Slowloris attacks.
		WriteTimeout: time.Second * 15,
		ReadTimeout:  time.Second * 15,
		IdleTimeout:  time.Second * 60,
		Handler:      r, // Pass our instance of gorilla/mux in.
	}

	// Run our server in a goroutine so that it doesn't block.
	go func() {
		if err := srv.ListenAndServe(); err != nil {
			log.Println(err)
		}
	}()

	// Create channel to listen for signals.
	signalChan := make(chan os.Signal, 1)
	// Accept graceful shutdowns when quit via SIGINT (Ctrl+C) or SIGTERM
	signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)

	// Block until receive signal.
	sig := <-signalChan
	log.Printf("%s signal caught", sig)

	// Create a deadline to wait for.
	ctx, cancel := context.WithTimeout(context.Background(), wait)
	defer cancel()

	// Add extra handling here to clean up resources, such as flushing logs and
	// closing any database or Redis connections.

	// Gracefully shutdown the server by waiting on existing requests (except websockets).
	if err := srv.Shutdown(ctx); err != nil {
		log.Printf("server shutdown failed: %+v", err)
	}
	log.Print("server exited")
	os.Exit(0)
}
```

### Liveness Probe and Readiness Probe

‡∏ñ‡πâ‡∏≤ API ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡∏≥‡πÑ‡∏õ Deploy ‡∏ö‡∏ô K8S ‡∏°‡∏µ‡∏≠‡∏µ‡∏Å 2 ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥ ‡∏Ñ‡∏∑‡∏≠

- **Liveness Probe** ‡∏Ñ‡∏∑‡∏≠ k8s ‡∏à‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ API ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏¢‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡∏•‡πà‡∏≤ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ ‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ú‡πà‡∏≤‡∏ô http ‡∏´‡∏£‡∏∑‡∏≠ tcp ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏ñ‡∏≤‡∏° ‡∏´‡∏£‡∏∑‡∏≠‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ cat file ‡πÅ‡∏ï‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ Graceful Shutdown ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ ‡∏°‡∏±‡∏ô‡∏à‡∏∞‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏±‡∏ö request ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏ã‡∏∂‡πà‡∏á‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ú‡πà‡∏≤‡∏ô http ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏à‡∏∞‡∏ó‡∏≥‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î Graceful Shutdown ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ cat file ‡πÅ‡∏ó‡∏ô ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏∞‡πÑ‡∏î‡πâ status 0 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
  **‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥**

  1. ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° ‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏¥‡πâ‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏ö‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°

     ```go:main.go
     func main() {
       _, err := os.Create("/tmp/live")
       if err != nil {
         log.Fatal(err)
       }
       defer os.Remove("/tmp/live")

       // ...
     }
     ```

  2. ‡πÉ‡∏ô k8s ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á cat file ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ

     ```yaml
     livenessProbe:
       exce:
         command:
           - cat
           - /tmp/live
       initialDelaySeconds: 5
       periodSeconds: 5
     ```

- **Readiness Probe** ‡∏Ñ‡∏∑‡∏≠ ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ service ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏∂‡∏¢‡∏±‡∏á ‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏≠‡∏∞‡πÑ‡∏£‡∏ö‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡∏à‡∏∂‡∏á‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡∏£‡∏±‡∏ö request ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÑ‡∏î‡πâ
  **‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥**

  1. ‡πÄ‡∏û‡∏¥‡πà‡∏° `/healthz` ‡πÅ‡∏•‡∏∞ `return 200 OK` ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

     ```go:main.go
     func setupRouter(r *mux.Router) {
       todo.HandleFunc("/healthz", handleHealthz).Methods(http.MethodGet)

       // ...
     }

     func handleHealthz(w http.ResponseWriter, r *http.Request) {
     	w.WriteHeader(http.StatusOK)
     }
     ```

  2. ‡πÉ‡∏ô k8s ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÑ‡∏õ‡∏¢‡∏±‡∏á **/healthz**

     ```yaml
     readinessProbe:
       httpGet:
         path: /healthz
         port: 8080
       initialDelaySeconds: 5
       periodSeconds: 5
     ```

### Logging

- **Transaction Id** ‡πÇ‡∏î‡∏¢‡∏õ‡∏Å‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á log ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ß‡πà‡∏≤ log ‡∏ô‡∏±‡πâ‡∏ô‡πÜ ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á transcation ‡∏≠‡∏∞‡πÑ‡∏£ ‡∏ö‡πâ‡∏≤‡∏á ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà‡∏á‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡∏Ñ‡∏∑‡∏≠ ‡πÉ‡∏´‡πâ‡∏ù‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏™‡πà‡∏á‡∏Ñ‡πà‡∏≤ unique id ‡∏°‡∏≤‡πÉ‡∏´‡πâ‡∏î‡πâ‡∏ß‡∏¢‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÅ‡∏•‡∏∞‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏≤‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏ô log ‡∏î‡πâ‡∏ß‡∏¢

```go
if err := tx.Error; err != nil {
	appErr := errs.NewUnexpectedError(err.Error())
	if errors.Is(err, gorm.ErrRecordNotFound) {
		appErr = errs.NewNotFoundError("todo with given id not found")
	}
  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á x-trasaction-id ‡πÄ‡∏õ‡πá‡∏ô uuid ‡∏°‡∏≤‡πÉ‡∏ô request header
  txId := r.Header.Get("x-transaction-id")
	log.Println(txId, appErr.Message)
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(appErr.Code)
	json.NewEncoder(w).Encode(appErr)
	return
}

// 2022/02/01 11:07:10 833d57ef-afb9-45c1-8450-9eff6559043e todo with given id not found
```

- **Structured Logging** ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏±‡πà‡∏á `log.Println()` ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤ ‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏¢‡∏≤‡∏Å ‡πÑ‡∏°‡πà‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ ‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏ß‡∏£‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á log ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ ‡πÄ‡∏ä‡πà‡∏ô

```go
2022/02/01 11:07:10 833d57ef-afb9-45c1-8450-9eff6559043e todo with given id not found

‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô

{
  "timestamp": "2022/02/01 11:07:10",
  "transactionId": "833d57ef-afb9-45c1-8450-9eff6559043e",
  "message": "todo with given id not found"
}
```

‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡∏°‡∏µ package ‡∏ó‡∏µ‡πà‡∏ô‡∏¥‡∏¢‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà 2 ‡∏ï‡∏±‡∏ß ‡∏Ñ‡∏∑‡∏≠ [zap](https://github.com/uber-go/zap) ‡∏Å‡∏±‡∏ö [logrus](https://github.com/sirupsen/logrus) ‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏ô‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ zap

```bash
go get -u go.uber.org/zap
```

‡∏™‡∏£‡πâ‡∏≤‡∏á logger module

```go:logger/logger.go
package logger

import (
	"fmt"

	"go.uber.org/zap"
)

var log *zap.Logger

func init() {
	fmt.Println("init log")
	var err error

	log, err = zap.NewProduction()

	if err != nil {
		panic(err)
	}
}

func Info(message string, fileds ...zap.Field) {
	log.Info(message, fileds...)
}

func Debug(message string, fileds ...zap.Field) {
	log.Debug(message, fileds...)
}

func Error(message string, fileds ...zap.Field) {
	log.Error(message, fileds...)
}
```

‡∏•‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```go:main.go
func main() {
  // ...
  logger.Info("Starting server at port 8080")
	log.Fatal(http.ListenAndServe(":8080", handler))
}

// {"level":"info","ts":1643702027.675124,"caller":"logger/logger.go:20","msg":"Starting server at port 8080"}
```

<aside>
üí° ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà caller ‡∏ô‡∏±‡πà‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÇ‡∏î‡∏¢ `zap.NewProduction(zap.AddCallerSkip(1))` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô log ‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á

</aside>

```go:logger/logger.go
func init() {
	var err error

	log, err = zap.NewProduction(zap.AddCallerSkip(1))

	if err != nil {
		panic(err)
	}
}
```

‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠ field ‡πÄ‡∏ä‡πà‡∏ô ts ‡πÄ‡∏õ‡πá‡∏ô timestamp ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô format ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ

```go:logger/logger.go
func init() {
	var err error

	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.TimeKey = "timestamp"
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

	config := zap.NewProductionConfig()
	config.EncoderConfig = encoderConfig

	log, err = config.Build(zap.AddCallerSkip(1))

	if err != nil {
		panic(err)
	}
}
// {"level":"info","timestamp":"2022-02-01T15:04:40.736+0700","caller":"goapi/main.go:39","msg":"Starting server at port 8080"}
```

<aside>
üí° ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á key ‡πÑ‡∏´‡∏ô‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÉ‡∏´‡πâ‡πÉ‡∏™‡πà `= ""` ‡πÄ‡∏ä‡πà‡∏ô `encoderConfig.StacktraceKey = ""`

</aside>

‡∏ñ‡πâ‡∏≤‡∏´‡∏≤‡∏Å log ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á Elastic ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ format ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏ô‡∏±‡πâ‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö plugin ECS loggers

‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô `go get go.elastic.co/ecszap`

```go:logger/logger.go
func init() {
	var err error

	config := zap.NewProductionConfig()
	config.EncoderConfig = ecszap.ECSCompatibleEncoderConfig(config.EncoderConfig)
	log, err = config.Build(ecszap.WrapCoreOption(), zap.AddCallerSkip(1))

	if err != nil {
		panic(err)
	}
}
```

<aside>
üí° ‡∏Å‡∏£‡∏ì‡∏µ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏° transactionId ‡∏ó‡∏≥‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ `zap.String("transactionId", txId)` ‡∏™‡πà‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡∏´‡∏•‡∏±‡∏á message

</aside>

## Deployment

‡πÄ‡∏°‡∏∑‡πà‡∏≠ API ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô Docker Image ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÉ‡∏ô Docker ‡∏´‡∏£‡∏∑‡∏≠ Kubernetes

### Dockerfile

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á Dockerfile ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á Docker image

```docker:Dockerfile
FROM golang:1.17-buster AS build
WORKDIR /app
COPY go.mod ./
COPY go.sum ./
RUN go mod download
COPY . ./
ENV GOARCH=amd64
RUN go build -o /go/bin/app

## Deploy
FROM gcr.io/distroless/base-debian11
COPY --from=build /go/bin/app /app
EXPOSE 8080
USER nonroot:nonroot
CMD ["/app"]
```

### Build Docker Image

‡∏™‡∏£‡πâ‡∏≤‡∏á docker image ‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á `docker build -t todo-api:1.0.0 -f Dockerfile .`

### Run with Docker-compose

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÑ‡∏î‡πâ docker image ‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏∞‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÉ‡∏ô docker ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏£‡∏±‡∏ô‡∏ú‡πà‡∏≤‡∏ô docker-compose ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏≥‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á `docker-compose.yml` ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ

```yaml:docker-compose.yml
version: '2.4'
services:
  db:
    image: postgres:12-alpine
    container_name: todo-db
    restart: always
    environment:
      - TZ=Asia/Bangkok
      - PGTZ=Asia/Bangkok
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=S3cretp@ssw0rd
      - POSTGRES_DB=todos
    volumes:
      - pg_data:/var/lib/postgresql/data
    logging:
      options:
        max-size: 10m
        max-file: '3'
    healthcheck:
      test: pg_isready -U postgres -h 127.0.0.1

  api:
    image: todo-api:1.0.0
    container_name: todo-api
    restart: always
    ports:
      - 8080:8080
    environment:
      - TZ=Asia/Bangkok
      - DB_DRIVER=postgres
      - DB_HOST=db
      - DB_PORT=5432
      - DB_USERNAME=postgres
      - DB_PASSWORD=S3cretp@ssw0rd
      - DB_DATABASE=todos
    depends_on:
      db:
        condition: service_healthy

volumes:
  pg_data:
```

‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á `docker-compose up -d`

---

‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á API Service ‡∏î‡πâ‡∏ß‡∏¢ Go ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏∞‡πÑ‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ö‡πâ‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á functional ‡πÅ‡∏•‡∏∞ non-functional ‡∏à‡∏ô‡πÑ‡∏õ‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£ Deploy ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á
