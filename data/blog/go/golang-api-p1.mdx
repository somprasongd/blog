---
title: 'API Service with Go: Zero to Production'
date: '2022-01-20'
lastmod: '2022-07-18'
tags: ['api', 'go']
draft: false
summary: '‡∏à‡∏∞‡∏™‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á API Service ‡∏î‡πâ‡∏ß‡∏¢‡∏†‡∏≤‡∏©‡∏≤ Go ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£ deploy ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á'
---

# API Service with Go: Zero to Production

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏†‡∏≤‡∏©‡∏≤ Go ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ CRUD ‡∏Å‡∏±‡∏ö Database ‡πÅ‡∏ö‡∏ö SQL ‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏ô‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÄ‡∏≠‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏°‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á API Service ‡∏Å‡∏±‡∏ô

‡πÇ‡∏î‡∏¢ API ‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Application 2 ‡∏ï‡∏±‡∏ß ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á UI ‡∏Å‡∏±‡∏ö Database ‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏∏‡∏¢‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î Protocal ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ô ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô REST ‡∏´‡∏£‡∏∑‡∏≠ GraphQL ‡∏´‡∏£‡∏∑‡∏≠ gRPC ‡∏Å‡πá‡πÑ‡∏î‡πâ

‡πÉ‡∏ô‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Todo List API ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ REST ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á web ui ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö-‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏Å‡∏±‡∏ô‡πÅ‡∏ö‡∏ö JSON ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å, ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤, ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó ‡πÅ‡∏•‡∏∞‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PostgreSQL

<aside>
üí° ‡∏à‡∏∞‡πÉ‡∏ä‡πâ Web UI ‡∏à‡∏≤‡∏Å [https://github.com/somprasongd/todo-react-app/tree/5-http-requests](https://github.com/somprasongd/todo-react-app/tree/5-http-requests)

</aside>

‡∏†‡∏≤‡∏¢‡πÉ‡∏ô API ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏à‡∏∞‡πÅ‡∏ö‡πà‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏õ‡πá‡∏ô 3 ‡∏™‡πà‡∏ß‡∏ô ‡∏Ñ‡∏∑‡∏≠

- Handler ‡∏ó‡∏≥‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
- Bussiness Logic ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á handler ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß
- Data Access Layer ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á‡πÜ

<div className="flex justify-center">
  <div>![Flow](/static/images/go/golang-api/flow.png)</div>
</div>

‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏π‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å [repo](https://github.com/somprasongd/blog-golang/tree/main/goapi) ‡∏ô‡∏µ‡πâ

## ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å HTTP Web Server

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Web Server ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ [net/http](https://pkg.go.dev/net/http) ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô standard library ‡∏Ç‡∏≠‡∏á Go ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢

### ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡πÉ‡∏´‡∏°‡πà

```bash
mkdir -p goapi
cd goapi
go mod init goapi
mkdir cmd
touch cmd/main.go
```

### ‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Web Server

```go:cmd/main.go
package main

import (
	"log"
	"net/http"
)

func main() {
	// starting server
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### ‡∏£‡∏±‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°

‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á `go run cmd/main.go`

<aside>
üí° ‡πÉ‡∏ô Windows ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á `go run cmd/main.go` ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å Windows Security Alert ‡∏ñ‡∏≤‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡πÅ‡∏Å‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å `":8080"` ‡πÄ‡∏õ‡πá‡∏ô `"localhost:8080"`

‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á Inboud Rules ‡πÉ‡∏ô Windows Defender Firewall ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ port 8080

</aside>

## ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö Request

‡πÄ‡∏°‡∏∑‡πà‡∏≠ server ‡∏£‡∏±‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏ï‡πà‡∏û‡∏≠‡∏•‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏ï‡πà‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° `404 page not found` ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏£‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á router ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö request ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤

### Handler Function

‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ Handler Function ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á router ‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏ó‡∏µ‡πà `/greet` ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ß‡πà‡∏≤ `Hello world` ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:cmd/main.go
func main() {
  // define route
	http.HandleFunc("/greet", func(w http.ResponseWriter, r *http.Request) {
	  fmt.Fprint(w, "Hello world")
  }

	// starting server
  log.Fatal(http.ListenAndServe(":8080", nil))
}
```

‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô ‡πÄ‡∏õ‡πá‡∏ô function ‡πÅ‡∏ó‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ

```go:cmd/main.go
func main() {
  // define route
	http.HandleFunc("/greet", greet)

	// starting server
  log.Fatal(http.ListenAndServe(":8080", nil))
}

func greet(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Hello world")
}
```

### Request and Response Headers

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡πÇ‡∏î‡∏¢‡∏ô‡∏≥‡∏à‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô struct ‡∏°‡∏≤‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ú‡πà‡∏≤‡∏ô `json.NewEncoder.(w).Encode(struct)`

```go:cmd/main.go
package main

import (
	"encoding/json"
	"log"
	"net/http"
)

type Test struct {
	Name string
}

func main() {
	// define route
	http.HandleFunc("/tests", handleTest)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func handleTest(w http.ResponseWriter, r *http.Request) {
	tests := []Test{
		{Name: "Test 1"},
		{Name: "Test 2"},
		{Name: "Test 3"},
	}

	json.NewEncoder(w).Encode(tests)
}
```

‡πÅ‡∏ï‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ô‡∏±‡πà‡∏ô‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô `text/plain` ‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏ `"Content-Type"` ‡πÉ‡∏ô Response Header ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ `w.Header().Add("header", "data")`

```go:cmd/main.go
func handleTest(w http.ResponseWriter, r *http.Request) {
	tests := []Test{
		{Name: "Test 1"},
		{Name: "Test 2"},
    {Name: "Test 3"},
	}

  w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(tests)
}
```

‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Request header ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ `r.Header.Get("header")`

```go:cmd/main.go
func handleTest(w http.ResponseWriter, r *http.Request) {
	tests := []Test{
		{Name: "Test 1"},
		{Name: "Test 2"},
    {Name: "Test 3"},
	}

  if r.Header.Get("Accept") == "application/xml" {
		w.Header().Add("Content-Type", "application/xml")
		xml.NewEncoder(w).Encode(tests)
	} else {
		w.Header().Add("Content-Type", "application/json")
		json.NewEncoder(w).Encode(tests)
	}
}
```

## ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Routing ‡∏î‡πâ‡∏ß‡∏¢ gorialla/mux

http handler ‡πÉ‡∏ô go ‡∏ô‡∏±‡πâ‡∏ô ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô mux ‡πÅ‡∏ó‡∏ô‡πÑ‡∏î‡πâ‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ

```go:cmd/main.go
func main() {
  mux := http.NewServeMux()
	// define route
	mux.HandleFunc("/tests", handleTest)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", mux))
}
```

‡πÅ‡∏ï‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤ [net/http](https://pkg.go.dev/net/http) ‡πÉ‡∏ô Go ‡∏ô‡∏±‡πâ‡∏ô ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á routing ‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏î‡∏µ ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏´‡∏≤ package ‡∏≠‡∏∑‡πà‡∏ô‡∏°‡∏≤‡∏ä‡πà‡∏ß‡∏¢‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏ó‡∏ô ‡πÇ‡∏î‡∏¢‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÉ‡∏ä‡πâ [gorilla/mux](https://github.com/gorilla/mux)

### ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á [gorilla/mux](https://github.com/gorilla/mux)

```bash
go get -u [github.com/gorilla/mux](http://github.com/gorilla/mux)
```

### ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô [gorilla/mux](https://github.com/gorilla/mux)

```go:cmd/main.go
import (
  "log"
  "net/http"
  "github.com/gorilla/mux"
)

func main() {
  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
  r := mux.NewRouter()
  // define route
	r.HandleFunc("/tests", handleTest)

	// starting server
  log.Fatal(http.ListenAndServe(":8080", r))
}
```

### Query Parameters

‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ `r.URL.Query()` ‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ `key` ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô `[]string`

```go:cmd/main.go
func handleTest(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(query)
}

// http://localhost:8080/tests?name=abc&completed=true
// {
// 	"completed": [
// 		"true"
// 	],
// 	"name": [
// 		"abc"
// 	]
// }
```

<aside>
üí° ‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á string ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô bool ‡πÉ‡∏ä‡πâ `strconv.ParseBool(query["completed"][0])`

</aside>

### URL Parameters

‡∏Å‡∏≥‡∏´‡∏ô‡∏î path ‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ `"/todos/{id}"` ‡πÅ‡∏•‡∏∞‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÉ‡∏ä‡πâ `mux.Vars(r)` ‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ `key` ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô `string`

```go:cmd/main.go
func main() {
	// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
	r := mux.NewRouter()
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	r.HandleFunc("/tests/{id:[0-9]+}", func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		fmt.Fprint(w, vars["id"])
	})

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}
```

<aside>
üí° ‡∏Ñ‡πà‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô string ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô int ‡πÉ‡∏ä‡πâ `strconv.Atoi(vars["id"])`

</aside>

### Methods

‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ method ‡πÅ‡∏Ñ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° `.Methods(http.MethodGet)` ‡πÑ‡∏õ‡∏´‡∏•‡∏±‡∏á `HandleFunc()` ‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ HandleFunc ‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞ Method ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏ä‡πà‡∏ô

```go:cmd/main.go
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

func main() {
	// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
	r := mux.NewRouter()
	// define route for crud
	r.HandleFunc("/tests", createTest).Methods(http.MethodPost)
  r.HandleFunc("/tests", listTest).Methods(http.MethodGet)
  // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
  r.HandleFunc("/tests/{id:[0-9]+}", getTest).Methods(http.MethodGet)
  r.HandleFunc("/tests/{id:[0-9]+}", updateTest).Methods(http.MethodPut)
  r.HandleFunc("/tests/{id:[0-9]+}", deleteTest).Methods(http.MethodDelete)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}
```

## ‡∏™‡∏£‡πâ‡∏≤‡∏á Todo List API

Todo List API ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á ‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

- Method POST `/api/todos` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà
- Method GET `/api/todos` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- Method GET `/api/todos/{id:[0-9]+}` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏° id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
- Method PATCH `/api/todos/{id:[0-9]+}` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ï‡∏≤‡∏° id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
- Method DELETE `/api/todos/{id:[0-9]+}` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏° id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏à‡∏≤‡∏Å handlers ‡∏ã‡∏∂‡πà‡∏á‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÅ‡∏¢‡∏Å‡πÑ‡∏ß‡πâ‡πÉ‡∏ô module handlers

```bash
mkdir -p pkg/handlers
cd pkg/handlers
touch todo.go
```

### ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å Todo struct

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å API ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö-‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á struct ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON

```go:pkg/handlers/todo.go
package handlers

type Todo struct {
	ID        int    `json:"id"`
	Text      string `json:"text"`
	Completed bool   `json:"isCompleted"`
}
```

<aside>
üí° ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å UI ‡∏à‡∏≤‡∏Å‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• JSON ‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô id, text ‡πÅ‡∏•‡∏∞ isCompleted ‡πÅ‡∏ï‡πà‡πÉ‡∏ô struct ‡∏ó‡∏µ‡πà‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà `tag json` ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ

</aside>

### ‡∏™‡∏£‡πâ‡∏≤‡∏á Handlers

‡∏™‡∏£‡πâ‡∏≤‡∏á handlers ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ routes ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

```go:pkg/handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Create Todo")
}

func ListTodo(w http.ResponseWriter, r *http.Request) {
  todos := []Todo{
		{ID: 1, Text: "Test 1", Completed: true},
		{ID: 2, Text: "Test 2", Completed: false},
		{ID: 3, Text: "Test 3", Completed: false},
	}
  // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todos)
}

func GetTodo(w http.ResponseWriter, r *http.Request) {
  vars := mux.Vars(r)
	fmt.Fprint(w, "Get Todo by ID:", vars["id"])
}

func UpdateTodoStatus(w http.ResponseWriter, r *http.Request) {
  vars := mux.Vars(r)
	fmt.Fprint(w, "Update Todo Status by ID:", vars["id"])
}

func DeleteTodo(w http.ResponseWriter, r *http.Request) {
  vars := mux.Vars(r)
	fmt.Fprint(w, "Delete Todo by ID:", vars["id"])
}
```

### ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Router

‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡∏∑‡πà‡∏≠ setupRouter() ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ routes ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏ó‡∏µ‡πà `main.go`

```go:cmd/main.go
package main

import (
	"goapi/pkg/handlers"
	"log"
	"net/http"

	"github.com/gorilla/mux"
)

type Test struct {
	Name string
}

func main() {
	// ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
	r := mux.NewRouter()
	// define route
	setupRouter(r)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}

func setupRouter(r *mux.Router) {
	r.HandleFunc("/api/todos", handlers.CreateTodo).Methods(http.MethodPost)
	r.HandleFunc("/api/todos", handlers.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	r.HandleFunc("/api/todos/{id:[0-9]+}", handlers.GetTodo).Methods(http.MethodGet)
	r.HandleFunc("/api/todos/{id:[0-9]+}", handlers.UpdateTodoStatus).Methods(http.MethodPut)
	r.HandleFunc("/api/todos/{id:[0-9]+}", handlers.DeleteTodo).Methods(http.MethodDelete)
}
```

‡πÅ‡∏ï‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô subrouter ‡πÅ‡∏ó‡∏ô‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏Ç‡∏≠‡∏á `/todos`

```go:cmd/main.go
func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
	todo.HandleFunc("", handlers.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", handlers.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", handlers.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", handlers.UpdateTodoStatus).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", handlers.DeleteTodo).Methods(http.MethodDelete)
}
```

## ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Database

‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∞‡πÑ‡∏õ‡∏•‡∏á logic ‡πÄ‡∏£‡∏≤‡∏°‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Database ‡∏£‡∏≠‡πÑ‡∏ß‡πâ‡∏Å‡πà‡∏≠‡∏ô ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏≤‡∏Å‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Database ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á [standard library](https://somprasongd.work/blog/go/golang-db-part1) ‡∏´‡∏£‡∏∑‡∏≠ [sqlx](https://somprasongd.work/blog/go/golang-db-part2) ‡∏´‡∏£‡∏∑‡∏≠ [gorm](https://somprasongd.work/blog/go/golang-db-part3) ‡∏Å‡πá‡πÑ‡∏î‡πâ‡∏ã‡∏∂‡πà‡∏á‡πÉ‡∏ô‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ [gorm](https://github.com/go-gorm/gorm) ‡πÅ‡∏•‡∏∞‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô PostgreSQL

- ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á [gorm](https://github.com/go-gorm/gorm) ‡πÅ‡∏•‡∏∞ database driver

```bash
go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres
```

- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Database ‡πÇ‡∏î‡∏¢‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå `pkg/common/database/gorm.go`

```go:pkg/common/database/gorm.go
package database

import (
	"log"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

const (
	// TODO fill this in directly or through environment variable
	// Build a DSN e.g. postgres://username:password@host:port/dbName
	// or "host=localhost user=gorm password=gorm dbname=gorm port=5432 sslmode=disable TimeZone=Asia/Bangkok"
	DB_DSN = "postgres://fcricryh:F5a7wATfocTUNww1Dm14AfebtPaysqIn@john.db.elephantsql.com/fcricryh"
)

var DB *gorm.DB

func ConnectDB() {
	var err error
	DB, err = gorm.Open(postgres.Open(DB_DSN), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})

	if err != nil {
		log.Fatal("Cannot open DB connection", err)
	}

	log.Println("DB Connected")
}
```

- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```go:cmd/main.go
func main() {
  // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î server ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ñ‡πâ‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á start server
	database.ConnectDB()


	r := mux.NewRouter()
	// define route
	setupRouter(r)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", r))
}
```

### ‡∏™‡∏£‡πâ‡∏≤‡∏á Model

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å GORM ‡πÄ‡∏õ‡πá‡∏ô ORM ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Model ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô `struct` ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô

‡πÉ‡∏´‡πâ‡πÑ‡∏õ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç `Todo` struct ‡πÉ‡∏ô `pkg/handlers/todo.go` ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠ column ‡πÉ‡∏ô databse ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≥‡∏´‡∏ô‡∏î gorm tag `column` ‡∏•‡∏á‡πÑ‡∏õ

```go:pkg/handlers/todo.go
type Todo struct {
	ID        int    `json:"id"`
	Text      string `json:"text" gorm:"column:title"`
	Completed bool   `json:"isCompleted" gorm:"column:is_done"`
}
```

## ‡πÉ‡∏™‡πà Bussiness Logic

‡∏ñ‡∏±‡∏î‡∏°‡∏≤‡∏à‡∏∞‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏±‡∏ô ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏™‡πà bussiness logic ‡∏ó‡∏µ‡πà handlers ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß ‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πà‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

### CreateTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method POST `/todos` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô JSON `{"text", "do something"}` ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Todo struct ‡∏ñ‡πâ‡∏≤‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 400 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	var todo Todo

	err := json.NewDecoder(r.Body).Decode(&todo)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

}
```

- Step 2: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 400 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  if todo.Title == "" {
    http.Error(w, "text is required", http.StatusBadRequest)
		return
  }
}
```

‡πÅ‡∏ï‡πà‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡πÜ fields ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ package [validator](https://github.com/go-playground/validator) ‡πÅ‡∏ó‡∏ô ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£ tag `validate` ‡∏•‡∏á‡πÑ‡∏õ‡πÉ‡∏ô struct

‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô validator ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏≠‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Ñ‡∏£‡∏≠‡∏ö package [validator](https://github.com/go-playground/validator) ‡πÑ‡∏ß‡πâ

```go:pkg/common/validator/validator.go
package validator

import (
	"errors"
	"strings"

	"github.com/go-playground/locales/en"
	ut "github.com/go-playground/universal-translator"
	"github.com/go-playground/validator/v10"
	en_translations "github.com/go-playground/validator/v10/translations/en"
)

// use a single instance , it caches struct info
var (
	uni      *ut.UniversalTranslator
	validate *validator.Validate
	trans    ut.Translator
)

func init() {
	en := en.New()
	uni = ut.New(en, en)
	// this is usually know or extracted from http 'Accept-Language' header
	// also see uni.FindTranslator(...)
	trans, _ = uni.GetTranslator("en")
	validate = validator.New()
	en_translations.RegisterDefaultTranslations(validate, trans)
}

func ValidateStruct(s interface{}) error {
	err := validate.Struct(s)
	if err != nil {
		return errors.New(errToMessage(err))
	}
	return nil
}

func errToMessage(err error) (message string) {
	// translate all error at once
	errs := err.(validator.ValidationErrors)
	fields := removeTopStruct(errs.Translate(trans))
	for k, v := range fields {
		message += ", " + k + ": " + v
	}
	return message[2:]
}

func removeTopStruct(fields map[string]string) map[string]string {
	res := map[string]string{}
	for field, err := range fields {
		res[strings.ToUpper(strings.ReplaceAll(field[strings.Index(field, ".")+1:], ".", "_"))] = err
	}
	return res
}
```

‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏±‡∏ô `go mod tidy` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î package ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```go:pkg/handlers/todo.go
type Todo struct {
	ID        int    `json:"id"`
	Text      string `json:"text" gorm:"column:title" validate:"required" `
	Completed bool   `json:"isCompleted" gorm:"column:is_done"`
}

func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  err = validator.ValidateStruct(todo)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
}
```

- Step 3: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 500 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  // step 3: insert
  tx := database.DB.Create(&todo)
  if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 4: ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô 201

```go:pkg/handlers/todo.go
func CreateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: ‡πÅ‡∏õ‡∏•‡∏á JSON ‡∏à‡∏≤‡∏Å request body ‡πÄ‡∏õ‡πá‡∏ô Todo struct
	// step 2: validate
  // step 3: insert
  // step 4: response
  w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(todo)
}
```

<aside>
üí° ‡πÇ‡∏î‡∏¢‡∏õ‡∏Å‡∏ï‡∏¥‡∏ñ‡πâ‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏à‡∏∞‡πÑ‡∏î‡πâ reponse status 200 ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô status ‡∏≠‡∏∑‡πà‡∏ô ‡πÄ‡∏ä‡πà‡∏ô ‡πÄ‡∏õ‡πá‡∏ô 201 ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ `w.WriteHeader(http.StatusCreated)` ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏•‡πà‡∏≤‡∏á `w.Header().Add()` ‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô header `"Content-Type"` ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ

</aside>

### ListTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method GET `/todos` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 500 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func ListTodo(w http.ResponseWriter, r *http.Request) {
  // step 1: query all todos from database
	todos := []Todo{}

	tx := database.DB.Find(&todos)

	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 2: ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON

```go:pkg/handlers/todo.go
func ListTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: query all todos from database
  // step 2: response
	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todos)
}
```

‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ó‡∏≤‡∏á query parameters ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡πá‡πÑ‡∏î‡πâ ‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

```go:pkg/handlers/todo.go
func ListTodo(w http.ResponseWriter, r *http.Request) {
  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å query params
  query := r.URL.Query()
  wheres := map[string]interface{}{}
  // ‡∏ñ‡πâ‡∏≤‡∏™‡πà‡∏á completed ‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡πÉ‡∏™‡πà‡πÑ‡∏õ‡πÉ‡∏ô map["is_done"] ‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠ column ‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
	if val, ok := query["completed"]; ok {
		b1, err := strconv.ParseBool(val[0])
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		wheres["is_done"] = b1
	}

  todos := []Todo{}
  // ‡πÄ‡∏û‡∏¥‡πà‡∏° .Where()
	tx := database.DB.Where(wheres).Find(&todos)

	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todos)
}
```

### GetTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method GET `/todos/{id:[0-9]+}` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ id ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

```go:pkg/handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
}
```

<aside>
üí° ‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡πà‡∏≤ id ‡∏à‡∏≤‡∏Å string ‡πÄ‡∏õ‡πá‡∏ô int ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö error ‡πÑ‡∏î‡πâ ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡πÉ‡∏ä‡πâ regex ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô

</aside>

- Step 2: ‡∏ô‡∏≥‡∏Ñ‡πà‡∏≤ id ‡πÑ‡∏õ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 500 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: select where id
	todo := Todo{}
	tx := database.DB.First(&todo, id)
	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 3: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 404 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: select where id
  todo := Todo{}
	tx := database.DB.First(&todo, id)
	if err := tx.Error; err != nil {
    // step 3: handle error not found
    if errors.Is(err, gorm.ErrRecordNotFound) {
      http.Error(w, "todo with given id not found", http.StatusNotFound)
		  return
    }
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 4: ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON

```go:pkg/handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: select where id
  // step 3: handle error not found
  // step 4: response
  w.Header().Add("Content-Type", "application/json")
	json.NewEncoder(w).Encode(todo)
}
```

### UpdateTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method PUT `/todos/{id:[0-9]+}` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ id ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

```go:pkg/handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
}
```

- Step 2: ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô JSON `{"isCompleted", true}` ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Todo struct

```go:pkg/handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  var todo Todo
	err := json.NewDecoder(r.Body).Decode(&todo)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
}
```

- Step 3: ‡∏ô‡∏≥‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏õ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å id ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏°‡∏≤

```go:pkg/handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  // step 3: update only is_done column
  tx := database.DB.Model(Todo{ID: id}).Update("is_done", todo.Completed)
	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 4: ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ id ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 404 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  // step 3: update only is_done column
  // step 4: handle not found error
  if tx.RowsAffected == 0 {
		http.Error(w, "todo with given id not found", http.StatusNotFound)
		return
	}
}
```

- Step 5: ‡∏ñ‡πâ‡∏≤‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡πÅ‡∏Ñ‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ 204 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: ‡πÅ‡∏õ‡∏•‡∏á json body ‡πÄ‡∏õ‡πá‡∏ô struct ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏≠‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
  // step 3: update only is_done column
  // step 4: handle not found error
  // step 5: response
  w.WriteHeader(http.StatusNoContent)
}
```

### DeleteTodo Handler

‡πÄ‡∏õ‡πá‡∏ô handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Method DELETE `/todos/{id:[0-9]+}` ‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ‡∏Ñ‡∏∑‡∏≠

- Step 1: ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤ id ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç

```go:pkg/handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
}
```

- Step 2: ‡∏ô‡∏≥‡∏Ñ‡πà‡∏≤ id ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏õ‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

```go:pkg/handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: delete where id
  tx := database.DB.Delete(&Todo{}, id)
	if err := tx.Error; err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}
```

- Step 3: ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ id ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤ ‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö error 404 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: delete where id
  // step 3: handle not found error
  if tx.RowsAffected <= 0 {
		http.Error(w, "todo with given id not found", http.StatusNotFound)
		return
	}
}
```

- Step 4: ‡∏ñ‡πâ‡∏≤‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡πÅ‡∏Ñ‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ 204 ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ

```go:pkg/handlers/todo.go
func DeleteTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
  // step 2: delete where id
  // step 3: handle not found error
  // step 4: response
  w.WriteHeader(http.StatusNoContent)
}
```

### Refactor

‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤ ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö JSON ‡∏à‡∏∞‡∏°‡∏µ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ã‡πâ‡∏≥‡πÜ ‡∏Å‡∏±‡∏ô ‡∏Ñ‡∏∑‡∏≠ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Content-Type, ‡∏Å‡∏≥‡∏´‡∏ô‡∏î respone code ‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á struct ‡πÄ‡∏õ‡πá‡∏ô JSON ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏≠‡∏≤‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏¢‡∏Å‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡πâ‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

```go:pkg/handlers/todo.go
func sendJson(w http.ResponseWriter, code int, data interface{}) {
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(data)
}
```

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏à‡∏∞‡∏î‡∏π clean ‡∏Ç‡∏∂‡πâ‡∏ô

```go:pkg/handlers/todo.go
func GetTodo(w http.ResponseWriter, r *http.Request) {
	// ...
	// step 4: response
	sendJson(w, http.StatusOK, todo)
}
```

### Use Method Style

‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡∏ä‡∏≠‡∏ö‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô handler ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á method ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ function ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡∏™‡πà‡∏á depencies ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏°‡∏≤‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á handler ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÅ‡∏ó‡∏ô

- ‡∏™‡∏£‡πâ‡∏≤‡∏á todoHandler struct ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≥‡∏´‡∏ô‡∏î depencies ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

```go:pkg/handlers/todo.go
type todoHandler struct {
	db       *gorm.DB
}

func NewTodoHandler(db *gorm.DB, validate *validator.Validate) *todoHandler {
	return &todoHandler{
		db:       db,
		validate: validate,
	}
}
```

- ‡πÅ‡∏Å‡πâ handlers function ‡πÄ‡∏õ‡πá‡∏ô method ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÄ‡∏õ‡πá‡∏ô receiver function

```go:pkg/handlers/todo.go
func (h todoHandler) CreateTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	tx := h.db.Create(&todo)
  // ...
}

func (h todoHandler) ListTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	tx := h.db.Where(wheres).Find(&todos)
  // ...
}

func (h todoHandler) GetTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	tx := h.db.First(&todo, id)
  // ...
}

func (h todoHandler) UpdateTodo(w http.ResponseWriter, r *http.Request) {
	// ...
	tx := h.db.Model(Todo{ID: uint(id)}).Update("is_done", todo.Completed)
  // ...
}

func (h todoHandler) DeleteTodo(w http.ResponseWriter, r *http.Request) {
  // ...
	tx := h.db.Delete(&Todo{}, id)
  // ...
}
```

- ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà `cmd/main.go`

```go:cmd/main.go
func main() {
  // ...
}

func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
	todoHandler := handlers.NewTodoHandler(database.DB)
	todo.HandleFunc("", todoHandler.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", todoHandler.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.UpdateTodo).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.DeleteTodo).Methods(http.MethodDelete)
}
```

## Error Handling

‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‡πÅ‡∏ï‡πà‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å API Service ‡∏ô‡∏µ‡πâ ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á JSON ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô

- ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á `AppError` ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô error ‡∏ó‡∏µ‡πà‡∏°‡∏µ status code ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà `pkg/common/errs/errs.go`

```go:pkg/common/errs/errs.go
package errs

import "net/http"

type AppError struct {
	Code    int    `json:"-"`
	Message string `json:"error"`
}

func (e AppError) Error() string {
	return e.Message
}

func NewBadRequestError(message string) error {
	return AppError{
		Code:    http.StatusBadRequest,
		Message: message,
	}
}

func NewNotFoundError(message string) error {
	return AppError{
		Code:    http.StatusNotFound,
		Message: message,
	}
}

func NewUnexpectedError(message string) error {
	return AppError{
		Code:    http.StatusInternalServerError,
		Message: message,
	}
}
```

- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ error ‡πÉ‡∏ô `pkg/handlers/todo.go`

```go:pkg/handlers/todo.go
func handleError(w http.ResponseWriter, err error) {
	switch e := err.(type) {
	case errs.AppError:
		sendJson(w, e.Code, e)
	case error:
		appErr := errs.AppError{
			Code:    http.StatusInternalServerError,
			Message: e.Error(),
		}
		sendJson(w, appErr.Code, appErr)
	}
}
```

- ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ error ‡∏î‡πâ‡∏ß‡∏¢ AppError

```go:pkg/handlers/todo.go
func (h todoHandler) GetTodo(w http.ResponseWriter, r *http.Request) {
	// step 1: get id from path param
	vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
	// step 2: select where id
	todo := Todo{}
	tx := h.db.First(&todo, id)
	if err := tx.Error; err != nil {
		// step 3: handle error not found
		if errors.Is(err, gorm.ErrRecordNotFound) {
			handleError(w, errs.NewNotFoundError("todo with given id not found"))
			return
		}
		handleError(w, errs.NewUnexpectedError(err.Error()))
		return
	}
	// step 4: response
	sendJson(w, http.StatusOK, todo)
}
```

## Middleware

Middleware ‡∏Ñ‡∏∑‡∏≠ function ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö handler ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô handler ‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏´‡πà‡∏≠ handler ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡∏ó‡∏≥‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å handler ‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à ‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ middleware ‡∏´‡πà‡∏≠‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÜ ‡∏ä‡∏±‡πâ‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏∞‡∏á‡∏≤‡∏ô‡∏à‡∏≤‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡∏≠‡∏Å‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á handler ‡πÅ‡∏•‡∏∞‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡πÉ‡∏ô‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡∏≠‡∏Å‡∏™‡∏∏‡∏î

‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏≠‡∏≤‡∏°‡∏≤‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ access log ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ authentication ‡∏Å‡πá‡πÑ‡∏î‡πâ

- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ Access log

```go:pkg/middleware/middleware.go
package middleware

import (
	"log"
	"net/http"
	"time"
)

func Logging(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, req)
		log.Printf("%s %s %s", req.Method, req.RequestURI, time.Since(start))
	})
}
```

- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏≥ Authentication

```go:pkg/middleware/middleware.go
type authenticationMiddleware struct {
	tokenUsers map[string]string
}

func NewAuthenticationMiddleware() *authenticationMiddleware {
	m := map[string]string{}
	m["1111"] = "user1"
	m["2222"] = "user2"

	return &authenticationMiddleware{
		tokenUsers: m,
	}
}

// Middleware function, which will be called for each request
func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("x-token")

		if user, found := amw.tokenUsers[token]; found {
			// We found the token in our map
			log.Printf("Authenticated user %s\n", user)
			// Pass down the request to the next middleware (or final handler)
			next.ServeHTTP(w, r)
		} else {
			// Write an error and stop the handler chain
			http.Error(w, "Forbidden", http.StatusForbidden)
		}
	})
}
```

- ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ

```go:cmd/main.go
func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
  todoHandler := handlers.NewTodoHandler(database.DB, validate)
	todo.HandleFunc("", todoHandler.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", todoHandler.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.UpdateTodo).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", todoHandler.DeleteTodo).Methods(http.MethodDelete)

	// Set up middleware.
	amw := middleware.NewAuthenticationMiddleware()
	r.Use(amw.Middleware)
	r.Use(middleware.Logging)
}

// request -> logging -> authen -> router
```

- ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ authen ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ `/api/todos`

```go:cmd/main.go
func setupRouter(r *mux.Router) {
	todo := r.PathPrefix("/api/todos").Subrouter()
	todo.HandleFunc("", handlers.CreateTodo).Methods(http.MethodPost)
	todo.HandleFunc("", handlers.ListTodo).Methods(http.MethodGet)
	// ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö regx ‡πÑ‡∏î‡πâ
	todo.HandleFunc("/{id:[0-9]+}", handlers.GetTodo).Methods(http.MethodGet)
	todo.HandleFunc("/{id:[0-9]+}", handlers.UpdateTodo).Methods(http.MethodPut)
	todo.HandleFunc("/{id:[0-9]+}", handlers.DeleteTodo).Methods(http.MethodDelete)

  r.HandleFunc("/public", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "This is public route")
	})
	// Set up middleware.
	amw := middleware.NewAuthenticationMiddleware()
	todo.Use(amw.Middleware)  // <-- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å r ‡πÄ‡∏õ‡πá‡∏ô todo ‡πÅ‡∏ó‡∏ô
	r.Use(middleware.Logging)
}

// request -> logging -> authen -> router
```

## **Handling CORS Requests**

‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏ô‡πâ‡∏≤ web ‡∏à‡∏≤‡∏Å repo ‡∏ô‡∏µ‡πâ

[GitHub - somprasongd/todo-react-app at 5-http-requests](https://github.com/somprasongd/todo-react-app/tree/5-http-requests)

<aside>
üí° ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏≠‡∏≤ authen middleware ‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô

</aside>

‡∏à‡∏∞‡∏û‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏∞‡πÑ‡∏£‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏°‡∏µ error `‚Äústrict-origin-when-cross-origin‚Äù` ‡∏ã‡∏∂‡πà‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ package [cors](https://github.com/rs/cors) ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏ä‡πà‡∏ß‡∏¢ ‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ

<aside>
üí° ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô `go get github.com/rs/cors`

</aside>

```go:cmd/main.go
func main() {
	// ...
	// ‡∏£‡∏±‡∏ö handler ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤
	handler := setupRouter(r)

	// starting server
	log.Fatal(http.ListenAndServe(":8080", handler))
}

// ‡πÄ‡∏û‡∏¥‡πà‡∏° return http.Handler
func setupRouter(r *mux.Router) http.Handler {
	// ...

	r.Use(middleware.Logging)

	// Handling CORS Requests
	c := cors.New(cors.Options{
		AllowCredentials: true,
		AllowedMethods:   []string{"GET", "POST", "PATCH", "DELETE", "OPTIONS"},
	})

	handler := c.Handler(r)
	return handler
}
```

## Non Functional Requirements

‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ API Service ‡∏ô‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏ï‡∏≤‡∏° requirements ‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏±‡πâ‡∏ô ‡∏¢‡∏±‡∏á‡∏°‡∏µ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÉ‡∏´‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏î‡πâ

### ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Configuration

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏Ñ‡πà‡∏≤ configurations ‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏° ‡πÄ‡∏ä‡πà‡∏ô server port ‡πÅ‡∏•‡∏∞ dsn ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö database ‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏•‡∏á‡πÑ‡∏õ‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏£‡∏á‡πÜ ‡∏Ñ‡∏ß‡∏£‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤ environments ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ñ‡∏π‡∏Å‡∏ô‡∏≥‡πÑ‡∏õ deploy [‡∏î‡∏π‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°](/blog/go/golang-api-p2-conf)

### ‡∏Ñ‡∏ß‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î Rate Limit

‡πÉ‡∏ô‡∏ö‡∏≤‡∏á‡∏Ñ‡∏£‡∏±‡πâ‡∏á api ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ô‡∏≤‡∏ô ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏¥‡∏ß‡∏£‡∏µ‡πà‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏õ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô api ‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô api ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏π‡∏á‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö request ‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ [‡∏î‡∏π‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°](/blog/go/golang-api-p3-ratelimit)

### ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ **Graceful Shutdown**

‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏±‡πâ‡∏ô ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞ shutdown ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏õ [‡∏î‡∏π‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°](/blog/go/golang-api-p4-graceful-shutdown)

### ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Liveness Probe ‡∏Å‡∏±‡∏ö Readiness Probe

‡∏ñ‡πâ‡∏≤ API ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡∏≥‡πÑ‡∏õ Deploy ‡∏ö‡∏ô K8S ‡∏°‡∏µ‡∏≠‡∏µ‡∏Å 2 ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥ ‡∏Ñ‡∏∑‡∏≠ Liveness Probe ‡∏Å‡∏±‡∏ö Readiness Probe [‡∏î‡∏π‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°](/blog/architecture/liveness-readiness-probe)

### ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ Logging

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á log ‡πÄ‡∏£‡∏≤‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏î‡∏µ ‡πÄ‡∏ä‡πà‡∏ô ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á transaction_id ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤ log ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡∏à‡∏≤‡∏Å request ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á log ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ô‡∏≥‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏™‡∏∞‡∏î‡∏ß‡∏Å [‡∏î‡∏π‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°](/blog/go/golang-api-p5-log)

## Deployment

‡πÄ‡∏°‡∏∑‡πà‡∏≠ API ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô Docker Image ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÉ‡∏ô Docker ‡∏´‡∏£‡∏∑‡∏≠ Kubernetes

### Dockerfile

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á Dockerfile ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏≥‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á Docker image

```docker:Dockerfile
FROM golang:1.18-buster AS build
WORKDIR /app
COPY go.mod ./
COPY go.sum ./
RUN go mod download
COPY cmd ./cmd
COPY pkg ./pkg
ENV GOARCH=amd64
RUN ls
RUN go build -o /go/bin/app cmd/main.go

## Deploy
FROM gcr.io/distroless/base-debian11
COPY --from=build /go/bin/app /app
EXPOSE 8080
USER nonroot:nonroot
CMD ["/app"]
```

### Build Docker Image

‡∏™‡∏£‡πâ‡∏≤‡∏á docker image ‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á `docker build -t todo-api:1.0.0 -f Dockerfile .`

### Run with Docker-compose

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÑ‡∏î‡πâ docker image ‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏∞‡∏ô‡∏≥‡πÑ‡∏õ deploy ‡πÉ‡∏ô docker ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏£‡∏±‡∏ô‡∏ú‡πà‡∏≤‡∏ô docker-compose ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏≥‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á `docker-compose.yml` ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ

```yaml:docker-compose.yml
version: '2.4'
services:
  db:
    image: postgres:12-alpine
    container_name: todo-db
    restart: always
    environment:
      - TZ=Asia/Bangkok
      - PGTZ=Asia/Bangkok
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=S3cretp@ssw0rd
      - POSTGRES_DB=todos
    volumes:
      - pg_data:/var/lib/postgresql/data
    logging:
      options:
        max-size: 10m
        max-file: '3'
    healthcheck:
      test: pg_isready -U postgres -h 127.0.0.1
      interval: 10s
      timeout: 5s
      retries: 5

  api:
    image: todo-api:1.0.0
    container_name: todo-api
    restart: always
    ports:
      - 8080:8080
    environment:
      - TZ=Asia/Bangkok
      - DB_DRIVER=postgres
      - DB_HOST=db
      - DB_PORT=5432
      - DB_USERNAME=postgres
      - DB_PASSWORD=S3cretp@ssw0rd
      - DB_DATABASE=todos
    depends_on:
      db:
        condition: service_healthy

volumes:
  pg_data:
```

‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á `docker-compose up -d`

---

‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á API Service ‡∏î‡πâ‡∏ß‡∏¢ Go ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏∞‡πÑ‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ö‡πâ‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á functional ‡πÅ‡∏•‡∏∞ non-functional ‡∏à‡∏ô‡πÑ‡∏õ‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£ Deploy ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á
