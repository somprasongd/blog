---
title: '‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á function handler ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡∏ó‡∏∏‡∏Å web framework'
date: '2022-06-24'
lastmod: '2022-06-24'
tags: ['go', 'api']
draft: false
summary: '‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á function handler ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡∏ó‡∏∏‡∏Å web framework'
---

# ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á function handler ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡∏ó‡∏∏‡∏Å web framework

‡πÇ‡∏î‡∏¢‡∏õ‡∏Å‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á API ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ ‡πÄ‡∏ä‡πà‡∏ô REST API ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Server ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏ß‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ request ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ path ‡∏à‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ function handler ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏°‡∏µ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡∏≤‡∏° HTTP Framework ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

‡∏™‡∏°‡∏°‡∏∏‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡πÉ‡∏ä‡πâ HTTP Framework ‡∏ï‡∏±‡∏ß‡∏≠‡∏∑‡πà‡∏ô ‡∏Å‡πá‡∏à‡∏∞‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏Å‡∏±‡∏ö function handler ‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤ ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏£‡∏≠‡∏ö ‡∏ã‡∏∂‡πà‡∏á‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÑ‡∏°‡πà‡πÄ‡∏¢‡∏≠‡∏∞‡∏Ñ‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏£

‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô ‡πÉ‡∏ô‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ function handler ‡∏Ç‡∏≠‡∏á routes ‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö HTTP framework ‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÇ‡∏î‡∏¢‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡πÅ‡∏Å‡πâ function handler ‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏†‡∏≤‡∏©‡∏≤ go ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Todo API

‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô Todo API ‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ http ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö [gorilla/mux](https://github.com/gorilla/mux)

```go:cmd/http/main.go
package main

import (
	"fmt"
	"goapi-handlefunc/handler"
	"net/http"

	"github.com/gorilla/mux"
)

const (
	BASE_URL = "/api/v1"
	PORT     = ":8080"
)

func main() {
	r := mux.NewRouter()
	// use gorilla/mux
	setRouter(r)

	http.ListenAndServe(PORT, r)
}

func setRouter(r *mux.Router) {
	h := handler.HTTPHandler{}

	todos := r.PathPrefix(BASE_URL + "/todos").Subrouter()
	todos.HandleFunc("", h.CreateHandler).Methods("POST")
	todos.HandleFunc("", h.ListHandler).Methods("GET")
	todos.HandleFunc("/{id:[0-9]+}", h.GetHandler).Methods("GET")
	todos.HandleFunc("/{id:[0-9]+}", h.StatusUpdateHandler).Methods("PATCH")
	todos.HandleFunc("/{id:[0-9]+}", h.DeleteHandler).Methods("DELETE")
}
```

‡∏°‡∏µ‡πÉ‡∏ä‡πâ http ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á handler function ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡∏≤‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ

```go
func (w http.ResponseWriter, r *http.Request) {

}
```

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á handlers ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

```go:handler/todo.go
package handler

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"github.com/gorilla/mux"
)

type Todo struct {
	ID        int    `json:"id"`
	Text      string `json:"text"`
	Completed bool   `json:"completed"`
}

type TodoHandler struct {
}

func (h TodoHandler) CreateHandler(w http.ResponseWriter, r *http.Request) {
	// bind json to new stuct
	var todo Todo
	err := json.NewDecoder(r.Body).Decode(&todo)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	// validate stuct if error return error reponse with status 400
	if todo.Text == "" {
		http.Error(w, "text is required", http.StatusBadRequest)
		return
	}
	// save
	// return json response with status 201
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(todo)
}

func (h TodoHandler) ListHandler(w http.ResponseWriter, r *http.Request) {
	// get query param for filter
	query := r.URL.Query()
	term := "Text"
	if val, ok := query["term"]; ok {
		term = val[0]
	}
	// list by filter
	todos := []Todo{
		{ID: 1, Text: term + "1", Completed: true},
		{ID: 2, Text: term + "2", Completed: false},
		{ID: 3, Text: term + "3", Completed: false},
	}
	// return json response with status 200
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(todos)
}

func (h TodoHandler) GetHandler(w http.ResponseWriter, r *http.Request) {
	// get id from path param
	vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
	// get by id
	todo := Todo{
		ID:        id,
		Text:      "Get Todo by ID",
		Completed: false,
	}
	// return json notfound error reponse if notfound with status 404
	// return json response with status 200
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(todo)
}

func (h TodoHandler) StatusUpdateHandler(w http.ResponseWriter, r *http.Request) {
	// get id from path param
	vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
	// bind json to patch stuct
	var updateTodo Todo
	err := json.NewDecoder(r.Body).Decode(&updateTodo)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	// get by id
	todo := Todo{
		ID:        id,
		Text:      "Update Todo Status by ID",
		Completed: false,
	}
	// return json notfound error reponse if notfound with status 404
	// udpate status
	todo.Completed = updateTodo.Completed
	// return json response with status 200
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(todo)
}

func (h TodoHandler) DeleteHandler(w http.ResponseWriter, r *http.Request) {
	// get id from path param
	vars := mux.Vars(r)
	id, _ := strconv.Atoi(vars["id"])
	// get by id
	// return json notfound error reponse if notfound with status 404
	// delete by id
	fmt.Println("Delete Todo by ID:", id)
	// return empty response with status 204
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(http.StatusNoContent)
	json.NewEncoder(w)
}
```

‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡∏à‡∏∞‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏∞‡πÇ‡∏Ñ‡πâ‡∏î‡∏≠‡∏¢‡∏π‡πà 2 ‡∏™‡πà‡∏ß‡∏ô ‡∏Ñ‡∏∑‡∏≠

1. ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏≤‡∏Å http framework ‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å json, query param, path param ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£ reponse ‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
2. Business Logic ‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏≤‡∏£ validate, ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å, ‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏•‡∏ö

‡∏™‡∏°‡∏°‡∏∏‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å http ‡πÑ‡∏õ‡πÄ‡∏õ‡πá‡∏ô gin ‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á handler function ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô

```go
func (c *gin.Context) {

}
```

‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏Å‡∏±‡∏ö‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1 ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ handler function ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏•‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å framework ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÉ‡∏´‡πâ handler function ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ‡πÅ‡∏ó‡∏ô

```go
func (c context.MyContext) {

}
```

## ‡∏™‡∏£‡πâ‡∏≤‡∏á MyContext

‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡πÄ‡∏£‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô http framework ‡∏≠‡∏¢‡∏π‡πà 4 ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏±‡∏ô‡∏Ñ‡∏∑‡∏≠

- ‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å JSON ‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô struct ‚Üí ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô method Bind()
- ‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å Query param ‚Üí ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô method Query()
- ‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å Path param ‚Üí ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô method Path()
- ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÅ‡∏ö‡∏ö JSON ‚Üí ‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô method JSON()

‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÄ‡∏≠‡∏≤‡∏ó‡∏±‡πâ‡∏á 4 method ‡∏ô‡∏µ‡πâ ‡πÅ‡∏•‡∏∞‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ ‡∏°‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô interface ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡πÑ‡∏õ implement ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞ framework ‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£

```go:context/context.go
package context

type MyContext interface {
	Bind(v interface{}) error                   // ‡∏£‡∏±‡∏ö struct pointer ‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏î‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ bind ‡∏à‡∏≤‡∏Å json boby
	BindQuery(interface{}) error                // ‡∏£‡∏±‡∏ö struct pointer ‡∏≠‡∏∞‡πÑ‡∏£‡∏Å‡πá‡πÑ‡∏î‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ bind ‡∏à‡∏≤‡∏Å query ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
	Query(k string) (string, bool)              // ‡∏£‡∏±‡∏ö key ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏à‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ false ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
	DefaultQuery(k string, d string) string     // ‡∏£‡∏±‡∏ö key ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ default ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
	Param(k string) string                      // ‡∏£‡∏±‡∏ö key ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
	Header(k string) string                     // ‡∏£‡∏±‡∏ö key ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
	RequestId() string                          // ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å header ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ö‡πà‡∏≠‡∏¢‡πÜ ‡πÄ‡∏ä‡πà‡∏ô X-Request-Id
	ResponseError(httpstatus int, err string)   // ‡∏™‡πà‡∏á json error ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≤‡∏° status ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
	ResponseJSON(httpstatus int, v interface{}) // ‡∏™‡πà‡∏á json ‡∏à‡∏≤‡∏Å struct ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≤‡∏° status ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
}
```

‡∏à‡∏≤‡∏Å‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏£‡∏≤‡πÉ‡∏ä‡πâ http ‡∏Å‡πá‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á `HTTPContext` ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤

```go:context/context_http.go
package context

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

type HttpContext struct {
	w http.ResponseWriter
	r *http.Request
}

func NewHttpContext(w http.ResponseWriter, r *http.Request) MyContext {
	return &HttpContext{
		w: w,
		r: r,
	}
}

func (c *HttpContext) Bind(v interface{}) error {
	return json.NewDecoder(c.r.Body).Decode(v)
}

func (c *HttpContext) BindQuery(v interface{}) error {
	querys := c.r.URL.Query()
	m := map[string]string{}
	for k, v := range querys {
		m[k] = v[0]
	}
	jsonStr, err := json.Marshal(m)
	if err != nil {
		return err
	}

	return json.NewDecoder(strings.NewReader(string(jsonStr))).Decode(v)
}

func (c *HttpContext) Query(key string) (string, bool) {
	query := c.r.URL.Query()
	if vals, ok := query[key]; ok {
		return vals[0], true
	}
	return "", false
}

func (c *HttpContext) DefaultQuery(key string, d string) string {
	query := c.r.URL.Query()
	if vals, ok := query[key]; ok {
		return vals[0]
	}
	return d
}

func (c *HttpContext) Param(key string) string {
	vars := mux.Vars(c.r)
	return vars[key]
}

func (c *HttpContext) Header(key string) string {
	return c.r.Header.Get(key)
}

func (c *HttpContext) RequestId() string {
	return c.Header("X-Request-Id")
}

func (c *HttpContext) ResponseError(code int, err string) {
	c.ResponseJSON(code, map[string]string{
		"error": err,
	})
}

func (c *HttpContext) ResponseJSON(code int, data interface{}) {
	c.w.Header().Add("Content-Type", "application/json")
	c.w.WriteHeader(code)
	if data != nil {
		json.NewEncoder(c.w).Encode(data)
	}
}
```

### ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Handlers ‡∏°‡∏≤‡πÉ‡∏ä‡πâ MyContext

‡∏ñ‡∏±‡∏î‡∏°‡∏≤‡πÉ‡∏´‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏∏‡∏Å handler function ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ MyContext ‡πÅ‡∏ó‡∏ô

- **CreateHandler** ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô `(w http.ResponseWriter, r *http.Request)` ‚Üí `(ctx MyContext)`

‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ `ctx.Bind()`, `ctx.ResponseError()` ‡πÅ‡∏•‡∏∞ `ctx.ResponseJSON()` ‡πÅ‡∏ó‡∏ô

```go:handler/todo.go
func (h TodoHandler) CreateHandler(ctx context.MyContext) {
	// bind json to new stuct
	var todo Todo
	err := ctx.Bind(&todo)
	if err != nil {
		ctx.ResponseError(http.StatusBadRequest, err.Error())
		return
	}
	// validate stuct if error return error reponse with status 400
	if todo.Text == "" {
		ctx.ResponseError(http.StatusBadRequest, "text is required")
		return
	}
	// save
	// return json response with status 201
	ctx.ResponseJSON(http.StatusCreated, todo)
}
```

- **ListHandler** ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô `(w http.ResponseWriter, r *http.Request)` ‚Üí `(ctx MyContext)`

‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ `ctx.Query()` ‡πÅ‡∏•‡∏∞ `ctx.ResponseJSON()` ‡πÅ‡∏ó‡∏ô

```go:handler/todo.go
func (h TodoHandler) ListHandler(ctx context.MyContext) {
	// get query param for filter
	term := "Text"
	if val, ok := ctx.Query("term"); ok {
		term = val
	}
	// list by filter
	todos := []Todo{
		{ID: 1, Text: term + "1", Completed: true},
		{ID: 2, Text: term + "2", Completed: false},
		{ID: 3, Text: term + "3", Completed: false},
	}
	// return json response with status 200
	ctx.ResponseJSON(http.StatusOK, todos)
}
```

- **GetHandler** ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô `(w http.ResponseWriter, r *http.Request)` ‚Üí `(ctx MyContext)`

‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ `ctx.Param()` ‡πÅ‡∏•‡∏∞ `ctx.ResponseJSON()` ‡πÅ‡∏ó‡∏ô

```go:handler/todo.go
func (h TodoHandler) GetHandler(ctx context.MyContext) {
	// get id from path param
	id, _ := strconv.Atoi(ctx.Param("id"))
	// get by id
	todo := Todo{
		ID:        id,
		Text:      "Get Todo by ID",
		Completed: false,
	}
	// return json notfound error reponse if notfound with status 404
	// return json response with status 200
	ctx.ResponseJSON(http.StatusOK, todo)
}
```

- **StatusUpdateHandler** ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô `(w http.ResponseWriter, r *http.Request)` ‚Üí `(ctx MyContext)`

‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ `ctx.Param()`, `ctx.Bind()`, `ctx.ResponseError()` ‡πÅ‡∏•‡∏∞ `ctx.ResponseJSON()` ‡πÅ‡∏ó‡∏ô

```go:handler/todo.go
func (h TodoHandler) StatusUpdateHandler(ctx context.MyContext) {
	// get id from path param
	id, _ := strconv.Atoi(ctx.Param("id"))
	// bind json to patch stuct
	var updateTodo Todo
	err := ctx.Bind(&updateTodo)
	if err != nil {
		ctx.ResponseError(http.StatusBadRequest, err.Error())
		return
	}
	// get by id
	todo := Todo{
		ID:        id,
		Text:      "Update Todo Status by ID",
		Completed: false,
	}
	// return json notfound error reponse if notfound with status 404
	// udpate status
	todo.Completed = updateTodo.Completed
	// return json response with status 200
	ctx.ResponseJSON(http.StatusOK, todo)
}
```

- **DeleteHandler** ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô `(w http.ResponseWriter, r *http.Request)` ‚Üí `(ctx MyContext)`

‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ `ctx.Param()` ‡πÅ‡∏•‡∏∞ `ctx.ResponseJSON()` ‡πÅ‡∏ó‡∏ô

```go:handler/todo.go
func (h TodoHandler) DeleteHandler(ctx context.MyContext) {
	// get id from path param
	id, _ := strconv.Atoi(ctx.Param("id"))
	// get by id
	// return json notfound error reponse if notfound with status 404
	// delete by id
	fmt.Println("Delete Todo by ID:", id)
	// return empty response with status 204
	ctx.ResponseJSON(http.StatusNoContent, nil)
}
```

### Router ‡∏û‡∏±‡∏á

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÅ‡∏Å‡πâ handler ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∞‡∏û‡∏ö‡∏ß‡πà‡∏≤‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á router ‡∏à‡∏∞ error

<div className="flex justify-center">
  <div>![Flow](/static/images/go/golang-api-handlefunc/router-error.png)</div>
</div>

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà router ‡∏Ç‡∏≠‡∏á gorilla/mux ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡∏Ñ‡∏∑‡∏≠ `func(http.ResponseWriter, *http.Request)` ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà `func(MyContext)` ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á wrapper function ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ ‡πÅ‡∏ö‡∏ö‡∏ô‡∏µ‡πâ

```go:context/context_http.go
func WrapHTTPHandler(h func(MyContext)) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		h(NewHttpContext(w, r))
	}
}
```

‡πÅ‡∏•‡πâ‡∏ß‡πÅ‡∏Å‡πâ‡∏ó‡∏µ‡πà `setRouter()`

```go:cmd/http/main.go
func setRouter(r *mux.Router) {
	h := handler.TodoHandler{}

	todos := r.PathPrefix(BASE_URL + "/todos").Subrouter()
	todos.HandleFunc("", context.WrapHTTPHandler(h.CreateHandler)).Methods("POST")
	todos.HandleFunc("", context.WrapHTTPHandler(h.ListHandler)).Methods("GET")
	todos.HandleFunc("/{id:[0-9]+}", context.WrapHTTPHandler(h.GetHandler)).Methods("GET")
	todos.HandleFunc("/{id:[0-9]+}", context.WrapHTTPHandler(h.StatusUpdateHandler)).Methods("PATCH")
	todos.HandleFunc("/{id:[0-9]+}", context.WrapHTTPHandler(h.DeleteHandler)).Methods("DELETE")
}
```

‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏Å‡πá‡∏à‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏õ‡∏Å‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß

### ‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ gin

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ [gin framework](https://github.com/gin-gonic/gin) ‡πÄ‡∏£‡∏≤‡∏Å‡πá‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á GinContext ‡πÅ‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ WrapGinHandler

```go:context/context_gin.go
package context

import (
	"github.com/gin-gonic/gin"
)

type GinContext struct {
	*gin.Context
}

func NewGinContext(c *gin.Context) MyContext {
	return &GinContext{
		Context: c,
	}
}

func (c *GinContext) Bind(v interface{}) error {
	return c.Context.ShouldBindJSON(v)
}

func (c *GinContext) BindQuery(v interface{}) error {
	return c.Context.ShouldBindQuery(v)
}

func (c *GinContext) Query(key string) (string, bool) {
	return c.Context.GetQuery(key)
}

func (c *GinContext) DefaultQuery(key string, d string) string {
	return c.Context.DefaultQuery(key, d)
}

func (c *GinContext) Param(key string) string {
	return c.Context.Param(key)
}

func (c *GinContext) Header(key string) string {
	return c.Context.GetHeader(key)
}

func (c *GinContext) RequestId() string {
	return c.Header("x-trace-id")
}
func (c *GinContext) ResponseError(code int, err string) {
	c.ResponseJSON(code, map[string]string{
		"error": err,
	})
}

func (c *GinContext) ResponseJSON(code int, data interface{}) {
	c.Context.JSON(code, data)
}

func WrapGinHandler(h func(MyContext)) gin.HandlerFunc {
	return func(c *gin.Context) {
		h(NewGinContext(c))
	}
}
```

‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Server ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ gin framework ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô handlers function ‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏¢

```go:cmd/gin/main.go
package main

import (
	"goapi-handlefunc/context"
	"goapi-handlefunc/handler"
	"net/http"

	"github.com/gin-gonic/gin"
)

const (
	BASE_URL = "/api/v1"
	PORT     = ":8080"
)

func main() {
	r := gin.Default()

	setRouter(r)

	http.ListenAndServe(PORT, r)
}

func setRouter(r *gin.Engine) {
	h := handler.TodoHandler{}

	todos := r.Group(BASE_URL + "/todos")
	todos.POST("", context.WrapGinHandler(h.CreateHandler))
	todos.GET("", context.WrapGinHandler(h.ListHandler))
	todos.GET("/:id", context.WrapGinHandler(h.GetHandler))
	todos.PATCH("/:id", context.WrapGinHandler(h.StatusUpdateHandler))
	todos.DELETE("/:id", context.WrapGinHandler(h.DeleteHandler))
}
```

### ‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ fiber

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡πÉ‡∏ä‡πâ [fiber framework](https://github.com/gofiber/fiber) ‡πÄ‡∏£‡∏≤‡∏Å‡πá‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á FiberContext ‡πÅ‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ WrapFiberHandler

```go:context/context_fiber.go
package context

import (
	"github.com/gofiber/fiber/v2"
)

type FiberContext struct {
	*fiber.Ctx
}

func NewFiberContext(c *fiber.Ctx) MyContext {
	return &FiberContext{
		Ctx: c,
	}
}

func (c *FiberContext) Bind(v interface{}) error {
	return c.Ctx.BodyParser(v)
}

func (c *FiberContext) BindQuery(v interface{}) error {
	return c.Ctx.QueryParser(v)
}

func (c *FiberContext) Query(key string) (string, bool) {
	q := c.Ctx.Query(key)
	return q, true
}

func (c *FiberContext) DefaultQuery(key string, d string) string {
	return c.Ctx.Query(key, d)
}

func (c *FiberContext) Param(key string) string {
	return c.Ctx.Params(key)
}

func (c *FiberContext) Header(key string) string {
	return c.Ctx.GetRespHeader(key)
}

func (c *FiberContext) RequestId() string {
	return c.Header("x-trace-id")
}

func (c *FiberContext) ResponseError(code int, err string) {
	c.ResponseJSON(code, map[string]string{
		"error": err,
	})
}

func (c *FiberContext) ResponseJSON(code int, data interface{}) {
	c.Ctx.SendStatus(code)
	c.Ctx.JSON(data)
}

func WrapFiberHandler(h func(MyContext)) func(*fiber.Ctx) error {
	return func(c *fiber.Ctx) error {
		h(NewFiberContext(c))
		return nil
	}
}
```

‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Server ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ gin framework ‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô handlers function ‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏¢

```go:cmd/fiber/main.go
package main

import (
	"goapi-handlefunc/context"
	"goapi-handlefunc/handler"

	"github.com/gofiber/fiber/v2"
)

const (
	BASE_URL = "/api/v1"
	PORT     = ":8080"
)

func main() {
	app := fiber.New()
	setRouter(app)

	app.Listen(PORT)
}

func setRouter(r *fiber.App) {
	h := handler.TodoHandler{}

	todos := r.Group(BASE_URL + "/todos")
	todos.Post("", context.WrapFiberHandler(h.CreateHandler))
	todos.Get("", context.WrapFiberHandler(h.ListHandler))
	todos.Get("/:id", context.WrapFiberHandler(h.GetHandler))
	todos.Patch("/:id", context.WrapFiberHandler(h.StatusUpdateHandler))
	todos.Delete("/:id", context.WrapFiberHandler(h.DeleteHandler))
}
```

---

‡∏™‡∏£‡∏∏‡∏õ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏≤‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô handlers function ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏°‡∏≤‡πÉ‡∏ä‡πâ interface MyContext ‡∏Å‡πá‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡πÉ‡∏ä‡πâ web framework ‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡πÑ‡∏î‡πâ‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏Å‡∏±‡∏ö‡πÇ‡∏Ñ‡πâ‡∏î‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤ ‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡∏à‡∏∞‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏Ñ‡πà 2 ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏∑‡∏≠

1. ‡∏™‡∏£‡πâ‡∏≤‡∏á Context ‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≤‡∏° web framework ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
2. ‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á HTTP Server ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Routers

‡∏ã‡∏∂‡πà‡∏á‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö handlers ‡∏Ç‡∏≠‡∏á message queue ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏õ implement context ‡∏Ç‡∏≠‡∏á message queue ‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤‡πÅ‡∏ó‡∏ô

<aside>
üí° ‡∏î‡∏π‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà [https://github.com/somprasongd/blog-golang/tree/main/goapi-handlefunc](https://github.com/somprasongd/blog-golang/tree/main/goapi-handlefunc)

</aside>
