---
title: 'API Service with Go: Graceful Shutdown'
date: '2022-02-04'
lastmod: '2022-07-27'
tags: ['api', 'go']
draft: false
summary: '‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏±‡πâ‡∏ô ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞ shutdown ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏õ'
---

# Graceful Shutdown

Graceful Shutdown ‡∏Ñ‡∏∑‡∏≠ ‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏±‡πâ‡∏ô ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞ shutdown ‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏õ

### ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏≥‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£

‡∏°‡∏≤‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ API Server ‡∏Å‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏ß‡πà‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏¢‡∏±‡∏á‡πÑ‡∏á ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ server ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡πÜ request ‡πÉ‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô ‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞ request ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö goroutine ‡∏Ñ‡∏∑‡∏≠‡πÅ‡∏¢‡∏Å thread ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ

‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ server ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô main thread ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏Ñ‡∏∑‡∏≠ goroutine ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏•‡∏á‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢

‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ ‡∏Ñ‡∏∑‡∏≠ ‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠‡πÉ‡∏´‡πâ goroutine ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡∏ã‡∏∂‡πà‡∏á‡∏°‡∏µ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏î‡∏±‡∏á‡∏ô‡∏µ‡πâ

1. ‡∏£‡∏≠‡∏£‡∏±‡∏ö signal ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
2. ‡∏´‡∏•‡∏±‡∏á‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö signal ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏±‡∏ö request ‡πÄ‡∏û‡∏¥‡πà‡∏°
3. ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô
4. Clean up resources ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤ ‡πÄ‡∏ä‡πà‡∏ô database connection ‡πÅ‡∏•‡∏∞ redis connection

‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∂‡∏á‡∏à‡∏∞‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÑ‡∏î‡πâ

### ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Web Server

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á web server ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ http

```go
package main

import (
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

func main() {
	r := mux.NewRouter()
	// Add your routes as needed
	r.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "OK")
	}).Methods("GET")

	port := 8080
	srv := &http.Server{
		Addr: fmt.Sprintf("0.0.0.0:%v", port),
		// Good practice to set timeouts to avoid Slowloris attacks.
		WriteTimeout: time.Second * 15,
		ReadTimeout:  time.Second * 15,
		IdleTimeout:  time.Second * 60,
		Handler:      r, // Pass our instance of gorilla/mux in.
	}

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != nil {
		log.Fatal(err)
	}
}
```

## ‡∏£‡∏≠‡∏£‡∏±‡∏ö Signal

Signal ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏à‡∏∞‡∏°‡∏µ 2 ‡∏ï‡∏±‡∏ß‡∏Ñ‡∏∑‡∏≠

- **SIGINT** ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì interrupt ‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏î Ctrl+c
- **SIGTERM** ‡πÄ‡∏ä‡πà‡∏ô ‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î pod ‡∏à‡∏≤‡∏Å Kubernates

‡πÇ‡∏î‡∏¢‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° goroutine ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏≠‡∏£‡∏±‡∏ö signal ‡∏Å‡πà‡∏≠‡∏ô start server

```go
func main() {
  // ...

  go gracefulShutdown()

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != nil {
		log.Fatal(err)
	}
}

func gracefulShutdown() {
	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGTERM)
	s := <-sig
	log.Printf("Received %v signal", s)
	os.Exit(0)
}
```

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î Ctrl+c ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° `Receive interrupt signal` ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á

## ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏±‡∏ö Request ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏™‡∏£‡πá‡∏à

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö signal ‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡∏™‡∏±‡πà‡∏á‡πÉ‡∏´‡πâ server ‡∏´‡∏¢‡∏∏‡∏î request ‡πÉ‡∏´‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡πÉ‡∏´‡πâ request ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô ‡πÇ‡∏î‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

```go
func main() {
	// ...

	go gracefulShutdown(srv)

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != nil {
		log.Fatal(err)
	}
	log.Println("Server shutdown successed")
}

func gracefulShutdown(srv *http.Server) {
	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGTERM)
	s := <-sig
	log.Printf("Received %v signal", s)

	err := srv.Shutdown(context.Background())
	if err != nil {
		log.Fatalf("Server shutdown failed: %+v\n", err)
	}
}
```

‡πÅ‡∏ï‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î Ctrl+c ‡∏à‡∏∞‡∏û‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° `Server shutdown successed` ‡πÅ‡∏ï‡πà‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ error ‡∏ß‡πà‡∏≤ `http: Server closed` ‡∏°‡∏≤‡πÅ‡∏ó‡∏ô ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà error ‡∏ô‡∏µ‡πâ ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞ panic ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤

```go
func main() {
	// ...

	go gracefulShutdown(srv)

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != http.ErrServerClosed {
		log.Fatal(err)
	}
}
```

‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏•‡∏≠‡∏á‡∏î‡∏π‡πÉ‡∏´‡∏°‡πà ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ error ‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡πá‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° `Server shutdown successed` ‡πÅ‡∏Å‡πâ‡πÇ‡∏î‡∏¢‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á `chan struct{}` ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡∏£‡∏±‡∏ö‡∏ß‡πà‡∏≤‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô gracefulShutdown ‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß

```go
func main() {
	// ...

	serverShutdown := make(chan struct{})

	go gracefulShutdown(srv, serverShutdown)

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != http.ErrServerClosed {
		log.Fatal(err)
	}
	<-serverShutdown

	log.Println("Server shutdown successed")
}

func gracefulShutdown(srv *http.Server, serverShutdown chan struct{}) {
	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGTERM)
	s := <-sig
	log.Printf("Received %v signal...", s)

	err := srv.Shutdown(context.Background())
	if err != nil {
		log.Fatalf("Server shutdown failed: %+v\n", err)
	}
	serverShutdown <- struct{}{}
}
```

## Clean up resources

‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡πÄ‡∏£‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏∑‡∏ô resources ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÄ‡∏ä‡πà‡∏ô ‡∏û‡∏ß‡∏Å database ‡∏´‡∏£‡∏∑‡∏≠ redis connection ‡πÇ‡∏î‡∏¢‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô `gracefulShutdown` ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß

```go
func main() {
	// ...

	go gracefulShutdown(srv)

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != nil {
		log.Fatal(err)
	}
	log.Println("Server shutdown successed")
  log.Println("Running cleanup tasks")
	// Add extra handling here to clean up resources, such as flushing logs and
	// closing any database or Redis connections.
}
```

## Shutdown timeout

‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡πÉ‡∏´‡πâ Server shutdown ‡πÄ‡∏£‡∏≤‡∏Ñ‡∏ß‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î timeout ‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏ß‡∏¢ ‡∏ã‡∏∂‡πà‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡πÑ‡∏î‡πâ ‡∏ï‡∏≤‡∏°‡∏ô‡∏µ‡πâ

```go
func main() {
	var timeout time.Duration
	flag.DurationVar(&timeout, "graceful-timeout", time.Second*15, "the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m")
	flag.Parse()

	// ...

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != http.ErrServerClosed {
		log.Fatal(err)
	}

	select {
	case <-serverShutdown:
		log.Println("Shutdown completed")
	case <-time.After(timeout):
		log.Println("Shutdown timeout")
	}

	log.Println("Running cleanup tasks")
	// Your cleanup tasks go here
}
```

‡∏•‡∏≠‡∏á‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£ ‡πÄ‡∏û‡∏¥‡πà‡∏° `time.Sleep(20 * time.Second)` ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ

```diff
func gracefulShutdown(srv *http.Server, serverShutdown chan struct{}) {
	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGTERM)
	s := <-sig
	log.Printf("Received %v signal...", s)

	err := srv.Shutdown(context.Background())
	if err != nil {
		log.Fatalf("Server shutdown failed: %+v\n", err)
	}
+	time.Sleep(20 * time.Second)
	serverShutdown <- struct{}{}
}
```

‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° `Shutdown timeout` ‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô Clean up ‡∏ï‡πà‡∏≠‡πÑ‡∏õ

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

```go
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gorilla/mux"
)

func main() {
	var timeout time.Duration
	flag.DurationVar(&timeout, "graceful-timeout", time.Second*15, "the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m")
	flag.Parse()

	r := mux.NewRouter()
	// Add your routes as needed
	r.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "OK")
	}).Methods("GET")

	port := 8080
	srv := &http.Server{
		Addr: fmt.Sprintf("0.0.0.0:%v", port),
		// Good practice to set timeouts to avoid Slowloris attacks.
		WriteTimeout: time.Second * 15,
		ReadTimeout:  time.Second * 15,
		IdleTimeout:  time.Second * 60,
		Handler:      r, // Pass our instance of gorilla/mux in.
	}

	serverShutdown := make(chan struct{})

	go gracefulShutdown(srv, serverShutdown)

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != http.ErrServerClosed {
		log.Fatal(err)
	}

	select {
	case <-serverShutdown:
		log.Println("Shutdown completed")
	case <-time.After(timeout):
		log.Println("Shutdown timeout")
	}

	log.Println("Running cleanup tasks")
	// Your cleanup tasks go here
}

func gracefulShutdown(srv *http.Server, serverShutdown chan struct{}) {
	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGTERM)
	s := <-sig
	log.Printf("Received %v signal...", s)

	err := srv.Shutdown(context.Background())
	if err != nil {
		log.Fatalf("Server shutdown failed: %+v\n", err)
	}

	serverShutdown <- struct{}{}
}
```

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Gin framework

<aside>
üí° ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö framework ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ http.Server ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

</aside>

```go
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
)

func main() {
	var timeout time.Duration
	flag.DurationVar(&timeout, "graceful-timeout", time.Second*15, "the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m")
	flag.Parse()

	r := gin.Default()
	// Add your routes as needed
	r.GET("/", func(ctx *gin.Context) {
		msg := "ok"
		ctx.Data(http.StatusOK, "text/plain", []byte(msg))
	})

	port := 8080
	srv := &http.Server{
		Addr: fmt.Sprintf("0.0.0.0:%v", port),
		// Good practice to set timeouts to avoid Slowloris attacks.
		WriteTimeout: time.Second * 15,
		ReadTimeout:  time.Second * 15,
		IdleTimeout:  time.Second * 60,
		Handler:      r, // Pass our instance of gorilla/mux in.
	}

	serverShutdown := make(chan struct{})

	go gracefulShutdown(srv, serverShutdown)

	log.Printf("Starting server at port %v\n", port)
	if err := srv.ListenAndServe(); err != http.ErrServerClosed {
		log.Fatal(err)
	}

	select {
	case <-serverShutdown:
		log.Println("Shutdown completed")
	case <-time.After(timeout):
		log.Println("Shutdown timeout")
	}

	log.Println("Running cleanup tasks")
	// Your cleanup tasks go here
}

func gracefulShutdown(srv *http.Server, serverShutdown chan struct{}) {
	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGTERM)
	s := <-sig
	log.Printf("Received %v signal...", s)

	err := srv.Shutdown(context.Background())
	if err != nil {
		log.Fatalf("Server shutdown failed: %+v\n", err)
	}

	serverShutdown <- struct{}{}
}
```

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Fiber framework

‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å fiber framework ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ http.Server ‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô ‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏á shutdown ‡∏à‡∏∞‡∏ï‡πà‡∏≤‡∏á‡πÑ‡∏õ ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡πà‡∏á `context.Background()` ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ

```go
package main

import (
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gofiber/fiber/v2"
)

func main() {
	var timeout time.Duration
	flag.DurationVar(&timeout, "graceful-timeout", time.Second*15, "the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m")
	flag.Parse()

	app := fiber.New()

	app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("ok")
	})

	serverShutdown := make(chan struct{})

	go gracefulShutdown(app, serverShutdown)

	// Run the server
	port := 8080
	log.Printf("Starting server at port %v\n", port)

	err := app.Listen(fmt.Sprintf("0.0.0.0:%v", port))
	if err != nil && err != http.ErrServerClosed {
		panic(err.Error())
	}

	select {
	case <-serverShutdown:
		log.Println("Shutdown completed")
	case <-time.After(timeout):
		log.Println("Shutdown timeout")
	}

	// <-serverShutdown
	log.Println("Running cleanup tasks")
	// Your cleanup tasks go here
}

func gracefulShutdown(srv *fiber.App, serverShutdown chan struct{}) {
	// Listen for syscall signals for process to interrupt/quit
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, os.Interrupt, syscall.SIGTERM)
	s := <-sig
	log.Printf("Received %v signal...", s)

	err := srv.Shutdown()
	if err != nil {
		log.Fatalf("Server shutdown failed: %+v\n", err)
	}
	serverShutdown <- struct{}{}
}
```

‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏π‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÑ‡∏î‡πâ[‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà](https://github.com/somprasongd/blog-golang/tree/main/goapi-graceful-shutdown)
